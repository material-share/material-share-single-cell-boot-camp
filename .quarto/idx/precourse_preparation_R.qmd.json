{"title":"Precourse Preparation - R","markdown":{"yaml":{"title":"Precourse Preparation - R","execute":{"warning":false,"message":false}},"headingText":"libraries for this chapter","containsRefs":false,"markdown":"\n\n```{r}\nlibrary(readxl)\nlibrary(data.table)\nlibrary(tidyverse)\nlibrary(Seurat)\n```\n\n# Introduction\n\nThis tutorial will help you to understand the basic concepts in R. It will cover the following topics:\n\n1.  Working with data frames\n2.  Tidyverse library\n3.  Understanding the Seurat object\n\nNote: If you are familiar with R and tidyverse package, you can skip this chapter.\n\n# 1. Data frame\n\n## 1.1 What is a data frame?\n\nData frame is a data structure in R that stores values of any type. You can think of it as a table with columns and rows storing the data as in the below example.\n\n![](prerequisite_figures/data_frame.png)\n\nCredit: https://www.geeksforgeeks.org/r-data-frames/\n\nOften in data science language, the columns are variables, the rows are observations and each entry in a table is a value.\n\nSome of the most common examples of input files that can be loaded into R as data frames are spreadsheets, TSVs, or CSVs files. TSV and CSV stands for tab-separated or coma-separated values.\n\nAnother way to view data frame is as a list of vectors of the same length. The vector can be defined as a type of data structure that contains elements of the same type. Below you can find example on how to create the table presented in the beyond figer from vectors.\n\n```{r}\n## Define vectors which will be used to create the data frame\n\n## Vector of names\nName <- c(\"Avrey Bradley\",\"John Holland\",\"Jonas Jerebko\",\"Jordan Midkey\",\"Terry Rozier\",\"Jared Sullinger\",\"Evan Turner\")\n\n## Vector of team's names\nTeam <- c(\"Boston Celtics\", \"Boston Celtics\",\"Boston Celtics\",\"Boston Celtics\",\"Boston Celtics\",\"Boston Celtics\",\"Boston Celtics\")\n\n## Vector of values\nNumber <- c(0.0,30.0,8.0,NaN,12.0,7.0,11.0)\n\n## Vector of positions\nPosition <- c(\"PG\",\"SG\",\"PF\",\"PF\",\"PG\",\"C\",\"SG\")\n\n## Vector of age\nAge <- c(25.0,27.0,29.0,21.0,22.0,NaN,27.0)\n\n## Create a data frame from vectors\ndata.frame(Name,Team,Number,Position,Age)\n```\n\n## 1.2 Convenient version of data frame: \"Tibble\"\n\nThe `tibble` is a package that manipulates data frames. The tibble type of table looks like a data frame but has some advantages over using regular data frames.\n\nFor example, while loading data as a classical data frame, the spaces in names are converted to periods or \"x\" before numeric columns is added. While using tibbles, the input names and data types remain unchanged. In this tutorial, we will work mainly with tibble data frame type.\n\n## 1.3 Working with data frames in R\n\n### 1.3.1 Example data\n\nIn this part of tutorial, we will work on table downloaded from supplementary data of Salcher, Stefan et al. (doi:10.1016/j.ccell.2022.10.008). The table contains the metadata of patients for which samples were processed on different single-cell platforms.\n\n### 1.3.2 Loading data\n\nDepending on the input format, there are different dedicated libraries to load data into R. Here we start from excel spreadsheet and use function from `readxl` library. The `readxl` library is part of `tidyverse` package that will be covered in second chapter of this tutorial.\n\n```{r}\ndf_example <- read_excel(\"data/precourse_preparation_data/mmc4.xlsx\", skip = 2)\n```\n\n**NOTE:**\n\n1.  The two first rows in the original table are empty, so we skip them when loading.\n\n2.  One of the columns in excel spreadsheet is empty (column N). The R assign automatically the default name `..1` to that column and keep it within the data frame.\n\n3.  All the missing entries in rows will be filled with \"NA\" values automatically.\n\n### 1.3.3 Viewing the content\n\nThere are different ways to view the content of data frame. You can directly click on `df_example` to display the content.\n\nThe `str` function lists directly in the console: the type of data (tibble), dimensions (322x18), columns with first values displayed and type of values.\n\n```{r}\nstr(df_example)\n```\n\n### 1.3.4 Extracting information\n\nExtracting data from a data frame means to access its rows or columns. First let's list all columns available in the data frame.\n\n```{r}\ncolnames(df_example)\n```\n\nTo extract values from single column of the data frame, different options can be used.\n\n-   Using `$` operator and providing the column name\n\n```{r}\ndf_example$study %>% head # head allows to display first few elements \n```\n\n-   Using `[[]]` and providing column number (index)\n\n```{r}\ndf_example[[2]] %>% head() # disply the first 6 elements in column 2\n```\n\n-   Using column name\n\n```{r}\ndf_example[, \"study\"] %>% head\n```\n\nTo extract multiple columns or rows at the same time, the following rules apply:\n\n![](prerequisite_figures/df_rows_columns.jpg)\n\n-   Extract rows range, include all columns.\n\n```{r}\ndf_example[c(2:4), ] #display rows from 2-4 and all columns\n```\n\n-   Extract rows, include all columns.\n\n```{r}\ndf_example[c(2,4),] #display rows 2 AND 4 and all columns\n```\n\n-   Extract columns range, include all rows.\n\n```{r}\ndf_example[, c(2:4)] %>% head #display columns from 2-4\n```\n\n-   Extract columns, include all rows.\n\n```{r}\ndf_example[, c(2,4)] %>% head #display columns 2 AND 4\n```\n\n::: callout-important\n-   **Exercise**\n\nExtract **rows** from 5-10 and **columns** from 3-8.\n:::\n\n::: {.callout-tip collapse=\"T\"}\n-   **Answer**\n\n```{r}\n#| eval: false\n\ndf_example[c(5:10), c(3,8)]\n```\n:::\n\n### 1.3.4 Modifying information\n\nThe columns or rows can be removed or added to data frame as needed. It is possible to drop specific columns indicating the column indexes.\n\n```{r}\nmodified_df_example <- df_example[, -c(1,2,5)]    # Drop columns 1,2,5\n```\n\nThe same principle apply to excluding the rows\n\n```{r}\nmodified_df_example <- df_example[-c(1,2,5),]     # Drop rows 1,2,5\n```\n\nWe can remove column with specific names. To drop column, we chose all the columns (called by \"colnames\") except (!=) \"patient\".\n\n```{r}\nmodified_df_example <- df_example[ , colnames(df_example) != \"patient\"]    # Drop column \"patient\"\n```\n\nWe can also add columns into data frame. To add new column, use `$` to indicate the column name for a new column as in the example below.\n\nHere we assign the values from already existing column to a new column. The new column is added at the end of the data table.\n\n```{r}\ndf_example$technology_type <- df_example$platform # add new column named \"technology_type\" with values from \"platform\" existing column\n```\n\nThe values from chosen column can be replaced with other values. In example below we search in `df_example` data frame in `technology_type` column for rows that contain \"BD-Rhapsody\" text. For those values we assign \"microwell-based\".\n\n```{r}\ndf_example$technology_type[df_example$technology_type == \"BD-Rhapsody\"] <- \"microwell-based\"\ndf_example$technology_type[df_example$technology_type == \"10x\"] <- \"droplet-based\"\n\ndf_example[,c(\"platform\",\"technology_type\")] %>% head #display columns\n```\n\nThe last useful function to cover in this chapter is `summary()`. The function gives the statistical summary of each of the columns when applied on data frame. It can be applied on slice of data as for example only on one column or chosen columns and rows.\n\n```{r}\nsummary(df_example)\n```\n\n```{r}\nsummary(df_example$age)\n```\n\n# 2. Tidyverse\n\nData often need to be re-shaped, re-arranged, and re-formatted, so that they can be visualized or used in downstream analysis. Throughout this chapter you will learn how to use the tidyverse library to navigate through and adjust the tables you work with.\n\nThe tidyverse is a collection of R packages. The core packages included in tidyverse are `ggplot2`, `tidyr`, `readr`, `dplyr`, `stringr`, `purrr`, and `forcats`. Each of the packages is dedicated to handle different operations. In below graphics, you can find a summary of all packages and their core functionalities.\n\n![](prerequisite_figures/tidyverse_libs_summary_graphics.png)\n\nCredit: https://www.storybench.org/getting-started-with-tidyverse-in-r/\n\nIn this chapter we will cover some of the functions that are going to be used during the course. If you would like to learn more about tidyverse and additional libraries, we encourage you to visit the official website <https://www.tidyverse.org/>.\n\nWhen `tidyverse` is loaded, you will see the list of packages included and loaded with tidyverse.\n\nAfter loading `tidyverse`, the R inform you about conflicting packages. The reason is that there are other packages already loaded by default in R.\n\nPackages consist of a collection of functions related to a particular purpose. Those functions can have naming conflicts with functions from other packages.\n\nThe two functions from `stats` package: `filer` and `lag`, exist as well in tidyverse. After loading tidyverse package, the functions from `stats` package are masked and by default the `tidyverse` functions will be used. If you would like to use `filter()` or `lag()` functions from `stats` package, you should indicate the package name as in example below.\n\n```{r}\n#| eval: false\n\nstats::filter()\n\n# Function in this example are empty for illustration purposes. To use that function you need to provide arguments inside.\n```\n\nWithout indicating the package name in front of function name, R will use the package that is loaded the most recently in your R session.\n\n## 2.1 Pipe\n\nA pipe `%>%` is a type of operator in `tidyverse`. It takes the output of one function and passes it as the first argument of the next function, allowing us to chain together several steps in R.\n\n![](prerequisite_figures/pipe_tidyverse.png)\n\nCredit: tidyverse.org\n\nThe pipe sends the data on left side of the pipe to be the first argument of the function on the right side of the pipe.\n\n```{r}\n16 %>% sqrt() # is equivalent to sqrt(16)\n```\n\nWe can pipe multiple functions together. The operations are performed from the left to the right sequentially.\n\n```{r}\n16 %>% sqrt() %>% log2() # is equivalent to log2(sqrt(16))\n```\n\nBelow you can find exercises with more examples of piping mathematical functions in R together.\n\n::: callout-important\n1.  Exercise: What would be the equivalent mathematical expression to below piped sequence of operations?\n\n```{r}\n#| eval: false\n\n26 %>% -22 %>% sqrt() %>% +4\n```\n:::\n\n::: {.callout-tip collapse=\"T\"}\n1.  Answer:\n\n```{r}\n#| eval: false\n\nsqrt(26-22) + 4\n```\n:::\n\n::: callout-important\n2.  Exercise: How below mathematical operation can be shown with pipe option?\n\n```{r}\n#| eval: false\n\nsqrt(log2(64)) - 8\n```\n:::\n\n::: {.callout-tip collapse=\"T\"}\n2.  Answer\n\n```{r}\n#| eval: false\n\n64 %>% log2() %>% sqrt() %>% -8\n```\n:::\n\n## 2.2 Example data\n\nIn this chapter we will work on an expression matrix table (gene expression) which is in CSV format. Below is example of how to load the table.\n\n```{r}\nexpMat <- fread(file = \"data/precourse_preparation_data/Demo-WTA-AbSeq.csv\", sep = \",\", header=TRUE)\n\n# file: provide full directory to file\n# sep: indicate separator, in this case coma\n# header = True is indicating to take the first row as a column names\n```\n\nDisplaying first rows and columns of the table gives us a glimpse on what the data contain.\n\n```{r}\nexpMat[c(1:5),c(1:5)]\n```\n\nThe gene names are displayed in columns and rows contain information about the cells. The column named V1 hold information about the cell index that is given to each cell in primary analysis.\n\nWe will set the V1 column as row names. In that way all the columns will contain the gene or protein counts.\n\n```{r}\n#use first column as row names\nexpMat <- data.frame(expMat, row.names = 1)\n```\n\nThe same set of above operations can be performed with pipe in one line of code. We read the file and convert first column to row names and save as data frame. The result is assigned to expMat variable by using the arrow.\n\n```{r}\n#pipe operations\nexpMat <- fread(file = \"data/precourse_preparation_data/Demo-WTA-AbSeq.csv\", sep = \",\", header=TRUE) %>% \n  data.frame(row.names = 1)\n```\n\n## 2.3 `select()`\n\n**Functionality:** Select only the columns (variables) that you want to see.\n\nImagine you are interested to extract the data only for one gene existing in your dataset. You can use the gene name, for example \"CD4\", to indicate in `select` function which column should be selected.\n\n```{r}\n# choosing the column of CD4 gene\nexpMat %>% dplyr::select(\"CD4\") -> CD4_column\n```\n\nIn the table we work on, the protein and gene expression information are provided. All the protein markers are labeled with \"pAbO\" abbreviation in addition to marker name. We can **select** all the columns that **contain** pAbO in name and save to new table.\n\n```{r}\n#choosing all the columns with AbSeq counts and saving to abseq_data\nexpMat %>% dplyr::select(contains(\"pAbO\")) -> abseq_data\n```\n\nAll the columns that does not contain the \"pAbO\" are representing genes. To create a gene data, we can use the `contains()` function with exclamation mark as in below example.\n\nThe \"!\" is used for negation in R language and is interpreted as \"do not\". Below expression will be interpreted as \"**select** from expMat columns that **do not** **contain** pAbO.\".\n\n```{r}\n# choosing all columns that does not contain AbSeq counts (mRNA only)\nexpMat %>% dplyr::select(!contains(\"pAbO\")) -> mrna_data\n```\n\n## 2.4 `mutate()`\n\n**Functionality:** Adds new columns or modifies current variables in the dataset.\n\nThe mutate function allows in easy way to add new columns in existing tables. Let's say we want to add column \"measurement_type\" and fill with \"protein expression\" in abseq data table we created in previous step.\n\n```{r}\n#add new column with the same value\nabseq_data %>% mutate(data_modality = \"protein_expression\") -> abseq_data \n```\n\nThe new column will be added at the end of table. We can show the column by selecting the column name.\n\n```{r}\n#display results\nabseq_data %>% dplyr::select(\"data_modality\") %>% head\n```\n\n`mutate()` function can be used in combination with other functions.\n\nIn this example, we will calculate sum of expression count for each cell and store the information in a table. We summarize the counts from all rows and add as a new column. The `rowSums` function is useful for calculating the sum of counts in each row.\n\n```{r}\nrowSums(mrna_data) -> mRNA_count_sum\n\n#display results\nmRNA_count_sum %>% head\n```\n\nAfter running `rowSums`, we got for each cell the number of counts. The values can be added in `mrna_data` data table as a new column.\n\n```{r}\nmrna_data %>% mutate(counts = mRNA_count_sum) -> mrna_data\nmrna_data %>% dplyr::select(counts) %>% head\n```\n\nThe same result can be generated with option below, where the `rowSums` function is nested inside the mutate function.\n\n```{r}\nmrna_data %>% mutate(counts = rowSums(mrna_data)) -> mrna_data\n```\n\nNotice that `mrna_data` is given twice in that case as an argument. The `mrna_data` is taken by `mutate` function as first argument and then in `rowSums` function as second argument.\n\nIn the above example we used pipe to direct the `mrna_data` to `mutate()` function as an argument. However the `mrna_data` was not forwarded by pipe to `rowSums`. For that reason we have to type it in the `rowSums` function. By default, the pipe operator forwards data only as first argument to a function. If you want the pipe to forward data as well as second (and next) argument to function you can use a dot.\n\n```{r}\nmrna_data %>% mutate(counts = rowSums(.)) -> mrna_data\n```\n\n## 2.5 `summarise()`\n\n**Functionality:** Collapse all rows and returns a one-row summary.\n\nIn the example below, `summarise` function allow us to calculate the max/min, median and mean values for counts.\n\n```{r}\nmrna_data %>% dplyr::summarise(mean = mean(counts),    #mean counts\n                             median = median(counts),    #median counts\n                             max = max(counts),    #maximum count\n                             min = min(counts))   #minimum count\n```\n\nIn above summary we have the overview of the expression range and how minimum and maximum values of molecules expressed differ. Some of cells will have very low transcriptome size in comparison to others.\n\n## 2.6 `if_else()`\n\nThe `if_else()` function in R is a conditional function. It allows to test the hypothesis and perform actions based on answer.\n\nLet's assume we want to label the cells according to transcriptom size. Based on threshold of counts we give a label of \"low_transcriptome\" or \"high_transcriptome\" for a cell status. We can make assumption that all cells with sum of counts lower then a threthold are low transcriptome cells and remaining cells are categorized as high transcriptome cells.\n\nThe `if_else` function with combination of mutate will help us to achieve the goal.\n\nFirst we need to know what is the structure of `if_else` statement. The first argument of `if_else` function is the hypotheses or the statement. We want to test if the counts for cell is below or above the threshold. Second argument is an action to perform if the statement is true. Third argument is an action to perform when the statement is false.\n\n![](prerequisite_figures/ifelse.jpg)\n\nIn our case, the hypothesis to test is if counts in a cell is below or above a threshold. We can set the condition to have a counts above 2000. If the counts are above the threshold the statement is true. When the statement is true the action is to set the label as \"high_transcriptome\". When the statement is false we set the label as \"low_transciptome\".\n\n```{r}\nif_else(mrna_data$counts > 2000, \"high_transcriptome\", \"low_transcriptome\") -> cell_status\n```\n\nIn that way we created a `cell_status` string based on counts. We should see `cell_status` that was generated has two labels. To verify if that is the case we can display the unique values of `cell_status`.\n\n```{r}\nunique(cell_status)\n```\n\nIf we would like to add that information as a new column to data table, we can use mutate function as in previous examples.\n\n```{r}\n#calcuate and add cell_status to mrna table\nmrna_data %>% mutate(cell_status = if_else(mrna_data[\"counts\"] > 2000, \"high_transcriptome\", \"low_transcriptome\")) -> mrna_data\n\n#display cell status column \nmrna_data %>% dplyr::select(cell_status) %>% head\n```\n\n## 2.7 `count()`\n\n**Functionality:** Collapse the rows and counts the number of observations per group of values.\n\nThe `count` function is a quick way to have an overview on number of occurrences. For example, we can use `count()` to see how many cells were categorized as low or high transcriptome cells.\n\n```{r}\nmrna_data %>% dplyr::count(cell_status)\n```\n\n## 2.8 `group_by()`\n\n**Functionality**: Take the existing data and group specific variables together for future operations.\n\nThe function takes an existing table and convert it into a grouped table where operations are performed by group.\n\nLet's have a look in the following example and assume that we want to compare the mean and median counts for low and high transcriptome cells. In that case we can group data by cell status and calculate average values for those groups.\n\n```{r}\nmrna_data %>% \n  group_by(cell_status) %>% \n  dplyr::summarize(mean = mean(counts),\n            median = median(counts),\n            n = n())  #calculates the total number of observations\n```\n\nIn the above code, we first group cells by cell status, meaning that calculations performed on our data will account for high transcriptome and low transcriptome cells separately. Following code execution, the console displays the mean count, the median count and the total number of cells (`n()`) for low transcriptome and for high transcriptome cells (`group_by(cell_status)`).\n\n## 2.8 `filter()`\n\n**Functionality:** Only retain specific rows of data that meet the specified requirement(s).\n\n`filter` function displays the data values that meet defined condition. For example, we can filter all cells with low transcriptome cell status and retain only high transcriptome cells.\n\n```{r}\nmrna_data %>% filter(cell_status == \"high_transcriptome\") -> signal_cells\n\n#display last column\nsignal_cells %>% dplyr::select(last_col()) %>% head()\n```\n\n## 2.9 `rename()`\n\n**Functionality:** Rename a column/variable by name and index.\n\nRename the cell_status variable as SIGNAL_CELLS (notice that the new label goes first in the argument).\n\n```{r}\nmrna_data %>% rename(SIGNAL_CELLS = cell_status) -> mrna_data\n\n#display results\nmrna_data %>% dplyr::select(last_col()) %>% head #chose last column from mrna_data\n```\n\n# 3. Seurat object\n\nSeurat object is a data structure designed for storing single-cell multiomics data and its information. We can think about Seurat object as a box with different sections to keep single-cell data in an organized manner.\n\nIn this chapter we will look at what information we can find in Seurat object and how to access them.\n\n## 3.1 Seurat Object Structure\n\nSeurat object stores information about the single cell multiomics data and the analysis that is performed. As we move through the workflow and make calculations, the results are added to Seurat object and stored in different \"boxes\". Those different \"boxes\" are called **slots**.\n\nLet's load an example Seurat object into R.\n\n```{r}\nseuratObj <- readRDS(\"data/precourse_preparation_data/seuratObj.rds\")\n```\n\nThe example Seurat object has a mRNA counts table. While Seurat object is generated, the following information are added to Seurat slots by default: assays, meta data, active assay, active identity, project name and version.\n\n![](prerequisite_figures/seurat_slots.jpg){width=\"200\"}\n\nThe remaining Seurat slots highlighted in grey are empty and will be filled with information during the analysis.\n\nYou can open the Seurat object in a separate tab and review its content.\n\n## 3.2 Assays\n\nThe `assays` slot contain different assays loaded into Seurat object. Those can be mRNA expression data or protein expression data. The `assay` slot has additional subslots that store the 'transformation' of the data, including raw counts (`counts` slot), normalized data (`data` slot), and scaled data for dimensional reduction (`scale.data` slot).\n\nThe assays slots can be accessed by function `GetAssayData`. In the example below, we access the `counts` slot.\n\n```{r}\n#Seurat object saved before normalization\nGetAssayData(object = seuratObj, slot = \"counts\") %>% \n  .[1:5 , c(\"6660551\",\"2066735\",\"9164959\",\"3709837\")]\n```\n\nWe can perform normalization and store the normalized counts in `data` slot.\n\n```{r}\n#Seurat object saved after normalization\nseuratObj <- NormalizeData(seuratObj)\n\nGetAssayData(object = seuratObj, slot = \"data\") %>% \n  .[1:5 , c(\"6660551\",\"2066735\",\"9164959\",\"3709837\")]\n```\n\nBy running above example, you can see the raw values in data slot are changed due to LogTransform normalization.\n\nBelow you can find a useful graphics indicating how data are altered in assays slots in Seurat object after applying different functions.\n\n![](prerequisite_figures/seurat_explained_cropped.png){width=\"800\"}\n\nCredit: Lior Pachter https://twitter.com/lpachter/status/1524413513233575936\n\n## 3.3 Meta Data\n\n`meta.data` slot stores information calculated for cells such as number of features and number of counts in each cell.\n\nThe `meta.data` information is stored in a table that can be accessed in Seurat object as below.\n\n```{r}\nseuratObj@meta.data %>% head\n```\n\nTo view list of all available meta.data in Seurat object we can view the column names from the data table.\n\n```{r}\nseuratObj@meta.data %>% colnames()\n```\n\nIt is possible to add new information to `meta.data`. It can be any information about the cells such as experimental batch or sub-population identity.\n\n```{r}\n#add meta data\nseuratObj <- AddMetaData(seuratObj, #indicate object\n            \"experiment_1\", #metadata to be added\n            \"batch\") #column name for metadata\n\n#display results\nseuratObj@meta.data %>% head\n```\n\n# 4. References and Resources\n\nFor more details, please consult:\n\n<https://www.geeksforgeeks.org/r-data-frames/>\n\n<https://bookdown.org/yih_huynh/Guide-to-R-Book/tidyverse.html>\n\n<https://silviacanelon.com/talk/2020-tour-of-the-tidyverse/>\n\n<https://oliviergimenez.github.io/intro_tidyverse/>\n\n<https://jhudatascience.org/tidyversecourse/get-data.html>\n\n<https://www.analyticsvidhya.com/blog/2019/05/beginner-guide-tidyverse-most-powerful-collection-r-packages-data-science/>\n","srcMarkdownNoYaml":"\n\n```{r}\n# libraries for this chapter\nlibrary(readxl)\nlibrary(data.table)\nlibrary(tidyverse)\nlibrary(Seurat)\n```\n\n# Introduction\n\nThis tutorial will help you to understand the basic concepts in R. It will cover the following topics:\n\n1.  Working with data frames\n2.  Tidyverse library\n3.  Understanding the Seurat object\n\nNote: If you are familiar with R and tidyverse package, you can skip this chapter.\n\n# 1. Data frame\n\n## 1.1 What is a data frame?\n\nData frame is a data structure in R that stores values of any type. You can think of it as a table with columns and rows storing the data as in the below example.\n\n![](prerequisite_figures/data_frame.png)\n\nCredit: https://www.geeksforgeeks.org/r-data-frames/\n\nOften in data science language, the columns are variables, the rows are observations and each entry in a table is a value.\n\nSome of the most common examples of input files that can be loaded into R as data frames are spreadsheets, TSVs, or CSVs files. TSV and CSV stands for tab-separated or coma-separated values.\n\nAnother way to view data frame is as a list of vectors of the same length. The vector can be defined as a type of data structure that contains elements of the same type. Below you can find example on how to create the table presented in the beyond figer from vectors.\n\n```{r}\n## Define vectors which will be used to create the data frame\n\n## Vector of names\nName <- c(\"Avrey Bradley\",\"John Holland\",\"Jonas Jerebko\",\"Jordan Midkey\",\"Terry Rozier\",\"Jared Sullinger\",\"Evan Turner\")\n\n## Vector of team's names\nTeam <- c(\"Boston Celtics\", \"Boston Celtics\",\"Boston Celtics\",\"Boston Celtics\",\"Boston Celtics\",\"Boston Celtics\",\"Boston Celtics\")\n\n## Vector of values\nNumber <- c(0.0,30.0,8.0,NaN,12.0,7.0,11.0)\n\n## Vector of positions\nPosition <- c(\"PG\",\"SG\",\"PF\",\"PF\",\"PG\",\"C\",\"SG\")\n\n## Vector of age\nAge <- c(25.0,27.0,29.0,21.0,22.0,NaN,27.0)\n\n## Create a data frame from vectors\ndata.frame(Name,Team,Number,Position,Age)\n```\n\n## 1.2 Convenient version of data frame: \"Tibble\"\n\nThe `tibble` is a package that manipulates data frames. The tibble type of table looks like a data frame but has some advantages over using regular data frames.\n\nFor example, while loading data as a classical data frame, the spaces in names are converted to periods or \"x\" before numeric columns is added. While using tibbles, the input names and data types remain unchanged. In this tutorial, we will work mainly with tibble data frame type.\n\n## 1.3 Working with data frames in R\n\n### 1.3.1 Example data\n\nIn this part of tutorial, we will work on table downloaded from supplementary data of Salcher, Stefan et al. (doi:10.1016/j.ccell.2022.10.008). The table contains the metadata of patients for which samples were processed on different single-cell platforms.\n\n### 1.3.2 Loading data\n\nDepending on the input format, there are different dedicated libraries to load data into R. Here we start from excel spreadsheet and use function from `readxl` library. The `readxl` library is part of `tidyverse` package that will be covered in second chapter of this tutorial.\n\n```{r}\ndf_example <- read_excel(\"data/precourse_preparation_data/mmc4.xlsx\", skip = 2)\n```\n\n**NOTE:**\n\n1.  The two first rows in the original table are empty, so we skip them when loading.\n\n2.  One of the columns in excel spreadsheet is empty (column N). The R assign automatically the default name `..1` to that column and keep it within the data frame.\n\n3.  All the missing entries in rows will be filled with \"NA\" values automatically.\n\n### 1.3.3 Viewing the content\n\nThere are different ways to view the content of data frame. You can directly click on `df_example` to display the content.\n\nThe `str` function lists directly in the console: the type of data (tibble), dimensions (322x18), columns with first values displayed and type of values.\n\n```{r}\nstr(df_example)\n```\n\n### 1.3.4 Extracting information\n\nExtracting data from a data frame means to access its rows or columns. First let's list all columns available in the data frame.\n\n```{r}\ncolnames(df_example)\n```\n\nTo extract values from single column of the data frame, different options can be used.\n\n-   Using `$` operator and providing the column name\n\n```{r}\ndf_example$study %>% head # head allows to display first few elements \n```\n\n-   Using `[[]]` and providing column number (index)\n\n```{r}\ndf_example[[2]] %>% head() # disply the first 6 elements in column 2\n```\n\n-   Using column name\n\n```{r}\ndf_example[, \"study\"] %>% head\n```\n\nTo extract multiple columns or rows at the same time, the following rules apply:\n\n![](prerequisite_figures/df_rows_columns.jpg)\n\n-   Extract rows range, include all columns.\n\n```{r}\ndf_example[c(2:4), ] #display rows from 2-4 and all columns\n```\n\n-   Extract rows, include all columns.\n\n```{r}\ndf_example[c(2,4),] #display rows 2 AND 4 and all columns\n```\n\n-   Extract columns range, include all rows.\n\n```{r}\ndf_example[, c(2:4)] %>% head #display columns from 2-4\n```\n\n-   Extract columns, include all rows.\n\n```{r}\ndf_example[, c(2,4)] %>% head #display columns 2 AND 4\n```\n\n::: callout-important\n-   **Exercise**\n\nExtract **rows** from 5-10 and **columns** from 3-8.\n:::\n\n::: {.callout-tip collapse=\"T\"}\n-   **Answer**\n\n```{r}\n#| eval: false\n\ndf_example[c(5:10), c(3,8)]\n```\n:::\n\n### 1.3.4 Modifying information\n\nThe columns or rows can be removed or added to data frame as needed. It is possible to drop specific columns indicating the column indexes.\n\n```{r}\nmodified_df_example <- df_example[, -c(1,2,5)]    # Drop columns 1,2,5\n```\n\nThe same principle apply to excluding the rows\n\n```{r}\nmodified_df_example <- df_example[-c(1,2,5),]     # Drop rows 1,2,5\n```\n\nWe can remove column with specific names. To drop column, we chose all the columns (called by \"colnames\") except (!=) \"patient\".\n\n```{r}\nmodified_df_example <- df_example[ , colnames(df_example) != \"patient\"]    # Drop column \"patient\"\n```\n\nWe can also add columns into data frame. To add new column, use `$` to indicate the column name for a new column as in the example below.\n\nHere we assign the values from already existing column to a new column. The new column is added at the end of the data table.\n\n```{r}\ndf_example$technology_type <- df_example$platform # add new column named \"technology_type\" with values from \"platform\" existing column\n```\n\nThe values from chosen column can be replaced with other values. In example below we search in `df_example` data frame in `technology_type` column for rows that contain \"BD-Rhapsody\" text. For those values we assign \"microwell-based\".\n\n```{r}\ndf_example$technology_type[df_example$technology_type == \"BD-Rhapsody\"] <- \"microwell-based\"\ndf_example$technology_type[df_example$technology_type == \"10x\"] <- \"droplet-based\"\n\ndf_example[,c(\"platform\",\"technology_type\")] %>% head #display columns\n```\n\nThe last useful function to cover in this chapter is `summary()`. The function gives the statistical summary of each of the columns when applied on data frame. It can be applied on slice of data as for example only on one column or chosen columns and rows.\n\n```{r}\nsummary(df_example)\n```\n\n```{r}\nsummary(df_example$age)\n```\n\n# 2. Tidyverse\n\nData often need to be re-shaped, re-arranged, and re-formatted, so that they can be visualized or used in downstream analysis. Throughout this chapter you will learn how to use the tidyverse library to navigate through and adjust the tables you work with.\n\nThe tidyverse is a collection of R packages. The core packages included in tidyverse are `ggplot2`, `tidyr`, `readr`, `dplyr`, `stringr`, `purrr`, and `forcats`. Each of the packages is dedicated to handle different operations. In below graphics, you can find a summary of all packages and their core functionalities.\n\n![](prerequisite_figures/tidyverse_libs_summary_graphics.png)\n\nCredit: https://www.storybench.org/getting-started-with-tidyverse-in-r/\n\nIn this chapter we will cover some of the functions that are going to be used during the course. If you would like to learn more about tidyverse and additional libraries, we encourage you to visit the official website <https://www.tidyverse.org/>.\n\nWhen `tidyverse` is loaded, you will see the list of packages included and loaded with tidyverse.\n\nAfter loading `tidyverse`, the R inform you about conflicting packages. The reason is that there are other packages already loaded by default in R.\n\nPackages consist of a collection of functions related to a particular purpose. Those functions can have naming conflicts with functions from other packages.\n\nThe two functions from `stats` package: `filer` and `lag`, exist as well in tidyverse. After loading tidyverse package, the functions from `stats` package are masked and by default the `tidyverse` functions will be used. If you would like to use `filter()` or `lag()` functions from `stats` package, you should indicate the package name as in example below.\n\n```{r}\n#| eval: false\n\nstats::filter()\n\n# Function in this example are empty for illustration purposes. To use that function you need to provide arguments inside.\n```\n\nWithout indicating the package name in front of function name, R will use the package that is loaded the most recently in your R session.\n\n## 2.1 Pipe\n\nA pipe `%>%` is a type of operator in `tidyverse`. It takes the output of one function and passes it as the first argument of the next function, allowing us to chain together several steps in R.\n\n![](prerequisite_figures/pipe_tidyverse.png)\n\nCredit: tidyverse.org\n\nThe pipe sends the data on left side of the pipe to be the first argument of the function on the right side of the pipe.\n\n```{r}\n16 %>% sqrt() # is equivalent to sqrt(16)\n```\n\nWe can pipe multiple functions together. The operations are performed from the left to the right sequentially.\n\n```{r}\n16 %>% sqrt() %>% log2() # is equivalent to log2(sqrt(16))\n```\n\nBelow you can find exercises with more examples of piping mathematical functions in R together.\n\n::: callout-important\n1.  Exercise: What would be the equivalent mathematical expression to below piped sequence of operations?\n\n```{r}\n#| eval: false\n\n26 %>% -22 %>% sqrt() %>% +4\n```\n:::\n\n::: {.callout-tip collapse=\"T\"}\n1.  Answer:\n\n```{r}\n#| eval: false\n\nsqrt(26-22) + 4\n```\n:::\n\n::: callout-important\n2.  Exercise: How below mathematical operation can be shown with pipe option?\n\n```{r}\n#| eval: false\n\nsqrt(log2(64)) - 8\n```\n:::\n\n::: {.callout-tip collapse=\"T\"}\n2.  Answer\n\n```{r}\n#| eval: false\n\n64 %>% log2() %>% sqrt() %>% -8\n```\n:::\n\n## 2.2 Example data\n\nIn this chapter we will work on an expression matrix table (gene expression) which is in CSV format. Below is example of how to load the table.\n\n```{r}\nexpMat <- fread(file = \"data/precourse_preparation_data/Demo-WTA-AbSeq.csv\", sep = \",\", header=TRUE)\n\n# file: provide full directory to file\n# sep: indicate separator, in this case coma\n# header = True is indicating to take the first row as a column names\n```\n\nDisplaying first rows and columns of the table gives us a glimpse on what the data contain.\n\n```{r}\nexpMat[c(1:5),c(1:5)]\n```\n\nThe gene names are displayed in columns and rows contain information about the cells. The column named V1 hold information about the cell index that is given to each cell in primary analysis.\n\nWe will set the V1 column as row names. In that way all the columns will contain the gene or protein counts.\n\n```{r}\n#use first column as row names\nexpMat <- data.frame(expMat, row.names = 1)\n```\n\nThe same set of above operations can be performed with pipe in one line of code. We read the file and convert first column to row names and save as data frame. The result is assigned to expMat variable by using the arrow.\n\n```{r}\n#pipe operations\nexpMat <- fread(file = \"data/precourse_preparation_data/Demo-WTA-AbSeq.csv\", sep = \",\", header=TRUE) %>% \n  data.frame(row.names = 1)\n```\n\n## 2.3 `select()`\n\n**Functionality:** Select only the columns (variables) that you want to see.\n\nImagine you are interested to extract the data only for one gene existing in your dataset. You can use the gene name, for example \"CD4\", to indicate in `select` function which column should be selected.\n\n```{r}\n# choosing the column of CD4 gene\nexpMat %>% dplyr::select(\"CD4\") -> CD4_column\n```\n\nIn the table we work on, the protein and gene expression information are provided. All the protein markers are labeled with \"pAbO\" abbreviation in addition to marker name. We can **select** all the columns that **contain** pAbO in name and save to new table.\n\n```{r}\n#choosing all the columns with AbSeq counts and saving to abseq_data\nexpMat %>% dplyr::select(contains(\"pAbO\")) -> abseq_data\n```\n\nAll the columns that does not contain the \"pAbO\" are representing genes. To create a gene data, we can use the `contains()` function with exclamation mark as in below example.\n\nThe \"!\" is used for negation in R language and is interpreted as \"do not\". Below expression will be interpreted as \"**select** from expMat columns that **do not** **contain** pAbO.\".\n\n```{r}\n# choosing all columns that does not contain AbSeq counts (mRNA only)\nexpMat %>% dplyr::select(!contains(\"pAbO\")) -> mrna_data\n```\n\n## 2.4 `mutate()`\n\n**Functionality:** Adds new columns or modifies current variables in the dataset.\n\nThe mutate function allows in easy way to add new columns in existing tables. Let's say we want to add column \"measurement_type\" and fill with \"protein expression\" in abseq data table we created in previous step.\n\n```{r}\n#add new column with the same value\nabseq_data %>% mutate(data_modality = \"protein_expression\") -> abseq_data \n```\n\nThe new column will be added at the end of table. We can show the column by selecting the column name.\n\n```{r}\n#display results\nabseq_data %>% dplyr::select(\"data_modality\") %>% head\n```\n\n`mutate()` function can be used in combination with other functions.\n\nIn this example, we will calculate sum of expression count for each cell and store the information in a table. We summarize the counts from all rows and add as a new column. The `rowSums` function is useful for calculating the sum of counts in each row.\n\n```{r}\nrowSums(mrna_data) -> mRNA_count_sum\n\n#display results\nmRNA_count_sum %>% head\n```\n\nAfter running `rowSums`, we got for each cell the number of counts. The values can be added in `mrna_data` data table as a new column.\n\n```{r}\nmrna_data %>% mutate(counts = mRNA_count_sum) -> mrna_data\nmrna_data %>% dplyr::select(counts) %>% head\n```\n\nThe same result can be generated with option below, where the `rowSums` function is nested inside the mutate function.\n\n```{r}\nmrna_data %>% mutate(counts = rowSums(mrna_data)) -> mrna_data\n```\n\nNotice that `mrna_data` is given twice in that case as an argument. The `mrna_data` is taken by `mutate` function as first argument and then in `rowSums` function as second argument.\n\nIn the above example we used pipe to direct the `mrna_data` to `mutate()` function as an argument. However the `mrna_data` was not forwarded by pipe to `rowSums`. For that reason we have to type it in the `rowSums` function. By default, the pipe operator forwards data only as first argument to a function. If you want the pipe to forward data as well as second (and next) argument to function you can use a dot.\n\n```{r}\nmrna_data %>% mutate(counts = rowSums(.)) -> mrna_data\n```\n\n## 2.5 `summarise()`\n\n**Functionality:** Collapse all rows and returns a one-row summary.\n\nIn the example below, `summarise` function allow us to calculate the max/min, median and mean values for counts.\n\n```{r}\nmrna_data %>% dplyr::summarise(mean = mean(counts),    #mean counts\n                             median = median(counts),    #median counts\n                             max = max(counts),    #maximum count\n                             min = min(counts))   #minimum count\n```\n\nIn above summary we have the overview of the expression range and how minimum and maximum values of molecules expressed differ. Some of cells will have very low transcriptome size in comparison to others.\n\n## 2.6 `if_else()`\n\nThe `if_else()` function in R is a conditional function. It allows to test the hypothesis and perform actions based on answer.\n\nLet's assume we want to label the cells according to transcriptom size. Based on threshold of counts we give a label of \"low_transcriptome\" or \"high_transcriptome\" for a cell status. We can make assumption that all cells with sum of counts lower then a threthold are low transcriptome cells and remaining cells are categorized as high transcriptome cells.\n\nThe `if_else` function with combination of mutate will help us to achieve the goal.\n\nFirst we need to know what is the structure of `if_else` statement. The first argument of `if_else` function is the hypotheses or the statement. We want to test if the counts for cell is below or above the threshold. Second argument is an action to perform if the statement is true. Third argument is an action to perform when the statement is false.\n\n![](prerequisite_figures/ifelse.jpg)\n\nIn our case, the hypothesis to test is if counts in a cell is below or above a threshold. We can set the condition to have a counts above 2000. If the counts are above the threshold the statement is true. When the statement is true the action is to set the label as \"high_transcriptome\". When the statement is false we set the label as \"low_transciptome\".\n\n```{r}\nif_else(mrna_data$counts > 2000, \"high_transcriptome\", \"low_transcriptome\") -> cell_status\n```\n\nIn that way we created a `cell_status` string based on counts. We should see `cell_status` that was generated has two labels. To verify if that is the case we can display the unique values of `cell_status`.\n\n```{r}\nunique(cell_status)\n```\n\nIf we would like to add that information as a new column to data table, we can use mutate function as in previous examples.\n\n```{r}\n#calcuate and add cell_status to mrna table\nmrna_data %>% mutate(cell_status = if_else(mrna_data[\"counts\"] > 2000, \"high_transcriptome\", \"low_transcriptome\")) -> mrna_data\n\n#display cell status column \nmrna_data %>% dplyr::select(cell_status) %>% head\n```\n\n## 2.7 `count()`\n\n**Functionality:** Collapse the rows and counts the number of observations per group of values.\n\nThe `count` function is a quick way to have an overview on number of occurrences. For example, we can use `count()` to see how many cells were categorized as low or high transcriptome cells.\n\n```{r}\nmrna_data %>% dplyr::count(cell_status)\n```\n\n## 2.8 `group_by()`\n\n**Functionality**: Take the existing data and group specific variables together for future operations.\n\nThe function takes an existing table and convert it into a grouped table where operations are performed by group.\n\nLet's have a look in the following example and assume that we want to compare the mean and median counts for low and high transcriptome cells. In that case we can group data by cell status and calculate average values for those groups.\n\n```{r}\nmrna_data %>% \n  group_by(cell_status) %>% \n  dplyr::summarize(mean = mean(counts),\n            median = median(counts),\n            n = n())  #calculates the total number of observations\n```\n\nIn the above code, we first group cells by cell status, meaning that calculations performed on our data will account for high transcriptome and low transcriptome cells separately. Following code execution, the console displays the mean count, the median count and the total number of cells (`n()`) for low transcriptome and for high transcriptome cells (`group_by(cell_status)`).\n\n## 2.8 `filter()`\n\n**Functionality:** Only retain specific rows of data that meet the specified requirement(s).\n\n`filter` function displays the data values that meet defined condition. For example, we can filter all cells with low transcriptome cell status and retain only high transcriptome cells.\n\n```{r}\nmrna_data %>% filter(cell_status == \"high_transcriptome\") -> signal_cells\n\n#display last column\nsignal_cells %>% dplyr::select(last_col()) %>% head()\n```\n\n## 2.9 `rename()`\n\n**Functionality:** Rename a column/variable by name and index.\n\nRename the cell_status variable as SIGNAL_CELLS (notice that the new label goes first in the argument).\n\n```{r}\nmrna_data %>% rename(SIGNAL_CELLS = cell_status) -> mrna_data\n\n#display results\nmrna_data %>% dplyr::select(last_col()) %>% head #chose last column from mrna_data\n```\n\n# 3. Seurat object\n\nSeurat object is a data structure designed for storing single-cell multiomics data and its information. We can think about Seurat object as a box with different sections to keep single-cell data in an organized manner.\n\nIn this chapter we will look at what information we can find in Seurat object and how to access them.\n\n## 3.1 Seurat Object Structure\n\nSeurat object stores information about the single cell multiomics data and the analysis that is performed. As we move through the workflow and make calculations, the results are added to Seurat object and stored in different \"boxes\". Those different \"boxes\" are called **slots**.\n\nLet's load an example Seurat object into R.\n\n```{r}\nseuratObj <- readRDS(\"data/precourse_preparation_data/seuratObj.rds\")\n```\n\nThe example Seurat object has a mRNA counts table. While Seurat object is generated, the following information are added to Seurat slots by default: assays, meta data, active assay, active identity, project name and version.\n\n![](prerequisite_figures/seurat_slots.jpg){width=\"200\"}\n\nThe remaining Seurat slots highlighted in grey are empty and will be filled with information during the analysis.\n\nYou can open the Seurat object in a separate tab and review its content.\n\n## 3.2 Assays\n\nThe `assays` slot contain different assays loaded into Seurat object. Those can be mRNA expression data or protein expression data. The `assay` slot has additional subslots that store the 'transformation' of the data, including raw counts (`counts` slot), normalized data (`data` slot), and scaled data for dimensional reduction (`scale.data` slot).\n\nThe assays slots can be accessed by function `GetAssayData`. In the example below, we access the `counts` slot.\n\n```{r}\n#Seurat object saved before normalization\nGetAssayData(object = seuratObj, slot = \"counts\") %>% \n  .[1:5 , c(\"6660551\",\"2066735\",\"9164959\",\"3709837\")]\n```\n\nWe can perform normalization and store the normalized counts in `data` slot.\n\n```{r}\n#Seurat object saved after normalization\nseuratObj <- NormalizeData(seuratObj)\n\nGetAssayData(object = seuratObj, slot = \"data\") %>% \n  .[1:5 , c(\"6660551\",\"2066735\",\"9164959\",\"3709837\")]\n```\n\nBy running above example, you can see the raw values in data slot are changed due to LogTransform normalization.\n\nBelow you can find a useful graphics indicating how data are altered in assays slots in Seurat object after applying different functions.\n\n![](prerequisite_figures/seurat_explained_cropped.png){width=\"800\"}\n\nCredit: Lior Pachter https://twitter.com/lpachter/status/1524413513233575936\n\n## 3.3 Meta Data\n\n`meta.data` slot stores information calculated for cells such as number of features and number of counts in each cell.\n\nThe `meta.data` information is stored in a table that can be accessed in Seurat object as below.\n\n```{r}\nseuratObj@meta.data %>% head\n```\n\nTo view list of all available meta.data in Seurat object we can view the column names from the data table.\n\n```{r}\nseuratObj@meta.data %>% colnames()\n```\n\nIt is possible to add new information to `meta.data`. It can be any information about the cells such as experimental batch or sub-population identity.\n\n```{r}\n#add meta data\nseuratObj <- AddMetaData(seuratObj, #indicate object\n            \"experiment_1\", #metadata to be added\n            \"batch\") #column name for metadata\n\n#display results\nseuratObj@meta.data %>% head\n```\n\n# 4. References and Resources\n\nFor more details, please consult:\n\n<https://www.geeksforgeeks.org/r-data-frames/>\n\n<https://bookdown.org/yih_huynh/Guide-to-R-Book/tidyverse.html>\n\n<https://silviacanelon.com/talk/2020-tour-of-the-tidyverse/>\n\n<https://oliviergimenez.github.io/intro_tidyverse/>\n\n<https://jhudatascience.org/tidyversecourse/get-data.html>\n\n<https://www.analyticsvidhya.com/blog/2019/05/beginner-guide-tidyverse-most-powerful-collection-r-packages-data-science/>\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":true,"freeze":"auto","echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"tidy":true,"message":false,"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":true,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"output-file":"precourse_preparation_R.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.340","theme":"cosmo","title":"Precourse Preparation - R"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}