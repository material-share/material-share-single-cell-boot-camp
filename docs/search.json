[
  {
    "objectID": "log.html",
    "href": "log.html",
    "title": "Log",
    "section": "",
    "text": "Seurat V4 Optional: The materials are updated to Seurat V5. If you want to use Seurat V4, you can follow the below instruction to install Seurat V4. Please note that you may need to adapt the code to fit Seurat V4 structure.\nFirst check the version of installed SeuratObject and Seurat.\n\npackageVersion(\"SeuratObject\")\npackageVersion(\"Seurat\")\n\nIf the version is 5.0.x, please follow the below instructions to remove the existing Seurat package and install Seurat V4.\n\nremove.packages(\"SeuratObject\")\nremove.packages(\"Seurat\")\n\npackageurl &lt;- \"https://cran.r-project.org/src/contrib/Archive/SeuratObject/SeuratObject_4.1.4.tar.gz\" \ninstall.packages(packageurl, repos=NULL, type=\"source\")\n\npackageurl &lt;- \"https://cran.r-project.org/src/contrib/Archive/Seurat/Seurat_4.4.0.tar.gz\" \ninstall.packages(packageurl, repos=NULL, type=\"source\")\n\n# Validate the installation is successful by running packageVersion.\n\npackageVersion(\"SeuratObject\")\npackageVersion(\"Seurat\")"
  },
  {
    "objectID": "log.html#section",
    "href": "log.html#section",
    "title": "Log",
    "section": "",
    "text": "Seurat V4 Optional: The materials are updated to Seurat V5. If you want to use Seurat V4, you can follow the below instruction to install Seurat V4. Please note that you may need to adapt the code to fit Seurat V4 structure.\nFirst check the version of installed SeuratObject and Seurat.\n\npackageVersion(\"SeuratObject\")\npackageVersion(\"Seurat\")\n\nIf the version is 5.0.x, please follow the below instructions to remove the existing Seurat package and install Seurat V4.\n\nremove.packages(\"SeuratObject\")\nremove.packages(\"Seurat\")\n\npackageurl &lt;- \"https://cran.r-project.org/src/contrib/Archive/SeuratObject/SeuratObject_4.1.4.tar.gz\" \ninstall.packages(packageurl, repos=NULL, type=\"source\")\n\npackageurl &lt;- \"https://cran.r-project.org/src/contrib/Archive/Seurat/Seurat_4.4.0.tar.gz\" \ninstall.packages(packageurl, repos=NULL, type=\"source\")\n\n# Validate the installation is successful by running packageVersion.\n\npackageVersion(\"SeuratObject\")\npackageVersion(\"Seurat\")"
  },
  {
    "objectID": "log.html#section-1",
    "href": "log.html#section-1",
    "title": "Log",
    "section": "20240423",
    "text": "20240423\nExtra plots\n\nseuratObj$test &lt;- ifelse(seuratObj$nFeature_RNA &lt; 300 | seuratObj$nCount_RNA &lt; 500, \"low\", \"high\")\n\n\nseuratObj@meta.data %&gt;%\n  ggplot(aes(x=nCount_RNA, y=nFeature_RNA, color=test)) +\n  geom_point() +\n  scale_colour_manual(values = c(\"black\", \"white\")) +\n  # stat_smooth(method=lm) +\n  scale_x_log10() +\n  scale_y_log10() +\n  theme_classic() +\n  geom_vline(xintercept = 500, colour = \"red\") +\n  geom_hline(yintercept = 300, colour = \"red\") +\n  facet_wrap(~Sample_Name) +\n  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))\n\nMove “multiplet” and “undetermined” removal to Chapter 02 Quality Control\nChapter 01 Update data import\n\n# update Seurat object\nseuratObj[[\"RNA\"]] &lt;- as(object = seuratObj[[\"RNA\"]], Class = \"Assay5\") \n\n# get bioproduct names for RNA and AbSeq\nab_name &lt;- grep(\"pAbO\", rownames(seuratObj), value = T, ignore.case = T)\nrna_name &lt;- rownames(seuratObj)[-which(rownames(seuratObj) %in% ab_name)]\n\n# get rna and AbSeq UMI counts, meta data\nab &lt;- GetAssayData(seuratObj[[\"RNA\"]], features = ab_name)\nrna &lt;- GetAssayData(seuratObj[[\"RNA\"]], features = rna_name)\n\n# recreate seurat object\nseuratObj[[\"RNA\"]] &lt;- CreateAssay5Object(counts = rna, min.cells = 0, min.features = 0)\nseuratObj[[\"ADT\"]] &lt;- CreateAssay5Object(counts = ab, min.cells = 0, min.features = 0)"
  },
  {
    "objectID": "log.html#section-2",
    "href": "log.html#section-2",
    "title": "Log",
    "section": "20240216",
    "text": "20240216\n\nUpdated to Seurat V5\nArchive precourse_preparation_theory.qmd for future development\nhttps://github.com/satijalab/seurat/issues/8202"
  },
  {
    "objectID": "log.html#section-3",
    "href": "log.html#section-3",
    "title": "Log",
    "section": "20231129",
    "text": "20231129\nThe following chapters have the below changes:\nChapter 7 Differential Expression Analysis\n\nRemove log2FC correlation plot."
  },
  {
    "objectID": "log.html#section-4",
    "href": "log.html#section-4",
    "title": "Log",
    "section": "20231128",
    "text": "20231128\nThe following chapters have the below changes:"
  },
  {
    "objectID": "log.html#setup",
    "href": "log.html#setup",
    "title": "Log",
    "section": "Setup",
    "text": "Setup\n\nAdd instruction to install Seurat V4.\nAdd instruction to update packages.\nDelete packages to be installed: SingleR, celldex, muscat.\nAdd packages to be installed: HGNChelper, ggpubr, RTools.\nUpdate Data download link."
  },
  {
    "objectID": "log.html#precourse-preperation---r",
    "href": "log.html#precourse-preperation---r",
    "title": "Log",
    "section": "Precourse preperation - R",
    "text": "Precourse preperation - R\n\nAdd data download link"
  },
  {
    "objectID": "log.html#chapter-5-clustering",
    "href": "log.html#chapter-5-clustering",
    "title": "Log",
    "section": "Chapter 5 Clustering",
    "text": "Chapter 5 Clustering\n\nAdd clustree"
  },
  {
    "objectID": "log.html#chapter-6-marker-identification",
    "href": "log.html#chapter-6-marker-identification",
    "title": "Log",
    "section": "Chapter 6 Marker Identification",
    "text": "Chapter 6 Marker Identification\n\nReplace singleR with ScType\n\nAdd VlnPlot stack plot"
  },
  {
    "objectID": "log.html#chapter-7-differential-expression-analysis",
    "href": "log.html#chapter-7-differential-expression-analysis",
    "title": "Log",
    "section": "Chapter 7 Differential Expression Analysis",
    "text": "Chapter 7 Differential Expression Analysis\n\nReplace muscat with functions in Seurat V4 to perform pseudobulk analysis"
  },
  {
    "objectID": "log.html#chapter-8",
    "href": "log.html#chapter-8",
    "title": "Log",
    "section": "Chapter 8",
    "text": "Chapter 8\n\nReplace ranking in GSEA gene list from stat to log2FC\nForce enrich bar plots to plot GO terms with the key word “T Cell”"
  },
  {
    "objectID": "log.html#error-log",
    "href": "log.html#error-log",
    "title": "Log",
    "section": "Error log",
    "text": "Error log\n\nWhen you run RunUMAP…\n\n\nSolution: Downgrading Matrix\nIf Mac is updated to Sonoma 14.x.x, you may see errors related to gfortran, like:\nld: warning: search path ‘/opt/R/arm64/gfortran/lib/gcc/aarch64-apple-darwin20.2.0/11.0.0’ not found\nld: warning: search path ‘/opt/R/arm64/gfortran/lib’ not found\nld: library ‘gfortran’ not found\nIf that’s the case, please download and install gfortran-12.2-universal.pkg https://cran.r-project.org/bin/macosx/tools/ before proceed.\n\ninstall.packages(\"remotes\")\nremotes::install_version(\"Matrix\", version = \"1.6-1\")\npackageVersion(\"Matrix\")\n\nSource: https://cran.r-project.org/bin/macosx/tools/\n\nWhen you run getBM…\n\n\nSolution: Downgrading dbplyr\n\ndevtools::install_version(\"dbplyr\", version = \"2.3.4\")\n\nSource: https://stackoverflow.com/questions/77370659/error-failed-to-collect-lazy-table-caused-by-error-in-db-collect-using\n\nWhen you run useMart…\n\n\nSolution: Go to http://status.ensembl.org to check the status of Ensembl. If it says service is down, wait a few hours and try again."
  },
  {
    "objectID": "bioinformatics_update.html",
    "href": "bioinformatics_update.html",
    "title": "Bioinformatics update",
    "section": "",
    "text": "https://www.biorxiv.org/content/10.1101/2024.04.04.588111v2"
  },
  {
    "objectID": "bioinformatics_update.html#the-impact-of-package-selection-and-versioning-on-single-cell-rna-seq-analysis",
    "href": "bioinformatics_update.html#the-impact-of-package-selection-and-versioning-on-single-cell-rna-seq-analysis",
    "title": "Bioinformatics update",
    "section": "",
    "text": "https://www.biorxiv.org/content/10.1101/2024.04.04.588111v2"
  },
  {
    "objectID": "bioinformatics_update.html#tcr-bcr-seq-analysis",
    "href": "bioinformatics_update.html#tcr-bcr-seq-analysis",
    "title": "Bioinformatics update",
    "section": "TCR-BCR-seq-analysis",
    "text": "TCR-BCR-seq-analysis\nhttps://github.com/crazyhottommy/TCR-BCR-seq-analysis"
  },
  {
    "objectID": "bioinformatics_update.html#mpg-primer-understand-single-cell-atac-seq-data-analysis-2024",
    "href": "bioinformatics_update.html#mpg-primer-understand-single-cell-atac-seq-data-analysis-2024",
    "title": "Bioinformatics update",
    "section": "MPG Primer: Understand Single Cell ATAC-Seq Data Analysis (2024)",
    "text": "MPG Primer: Understand Single Cell ATAC-Seq Data Analysis (2024)\nhttps://www.youtube.com/watch?v=sUq4yTIJqvk&t=555s"
  },
  {
    "objectID": "bioinformatics_update.html#sctopogan-diagnosis-of-single-cell-rna-seq-data-using-topological-generative-adversarial-networks",
    "href": "bioinformatics_update.html#sctopogan-diagnosis-of-single-cell-rna-seq-data-using-topological-generative-adversarial-networks",
    "title": "Bioinformatics update",
    "section": "scTopoGAN: Diagnosis of single-cell RNA-seq data using topological generative adversarial networks",
    "text": "scTopoGAN: Diagnosis of single-cell RNA-seq data using topological generative adversarial networks\nhttps://academic.oup.com/bioinformaticsadvances/article/3/1/vbad171/7450146"
  },
  {
    "objectID": "bioinformatics_update.html#review-article-single-cell-immune-repertoire-analysis",
    "href": "bioinformatics_update.html#review-article-single-cell-immune-repertoire-analysis",
    "title": "Bioinformatics update",
    "section": "Review article: Single-cell immune repertoire analysis",
    "text": "Review article: Single-cell immune repertoire analysis\nhttps://www.nature.com/articles/s41592-024-02243-4"
  },
  {
    "objectID": "bioinformatics_update.html#gptcelltype",
    "href": "bioinformatics_update.html#gptcelltype",
    "title": "Bioinformatics update",
    "section": "GPTCelltype",
    "text": "GPTCelltype\nGithub repository: https://github.com/Winnie09/GPTCelltype\nGPTCelltype is a package that uses OpenAI’s GPT-3 and GPT-4 models to annotate cell types based on marker genes. The package is designed to work with Seurat objects and can be used to annotate cell types in single-cell RNA-seq data."
  },
  {
    "objectID": "07_differential_expression_analysis.html",
    "href": "07_differential_expression_analysis.html",
    "title": "7. Differential Expression Analysis",
    "section": "",
    "text": "# libraries for this chapter\nlibrary(tidyverse)\nlibrary(Seurat)\nlibrary(data.table)\nlibrary(ggpubr)\nNow that we’ve annotated the clusters, our next step is to identify differentially expressed genes (DEGs) between samples within each cell type. This involves performing differential expression analysis."
  },
  {
    "objectID": "07_differential_expression_analysis.html#findmarkers",
    "href": "07_differential_expression_analysis.html#findmarkers",
    "title": "7. Differential Expression Analysis",
    "section": "1. FindMarkers",
    "text": "1. FindMarkers\n1.1 DE analysis across conditions\nIn the previous chapter, we used the FindMarkers function to identify marker genes between two clusters by specifying ident.1 and ident.2.\nNow, let’s shift our focus to differential expression analysis between two groups. By adjusting the ident.1 and ident.2 arguments, we can compare gene expression levels between these groups.\nFor example, if we want to find genes that are differentially expressed between naïve and treated PBMCs, we can select groups:\nident.1 (SampleTag02_hs): Treated PBMC\nident.2 (SampleTag01_hs): Naïve PBMC\n\n# change default assay to \"RNA\"\nDefaultAssay(filtered) &lt;- \"RNA\"\n\n# change default identity to \"Sample_Name\"\nIdents(filtered) &lt;- \"Sample_Name\"\n\n# Find genes differentially expressed\n# SampleTag02_hs: treated, SampleTag01_hs: naive\ntreated_naive &lt;- \n  FindMarkers(filtered, ident.1 = \"SampleTag02_hs\", ident.2 = \"SampleTag01_hs\") %&gt;% \n  rownames_to_column(\"gene\") %&gt;% \n  dplyr::filter(p_val_adj &lt; 0.05)\n\n# look at the top DEGs\nhead(treated_naive, n = 5)\n\n   gene         p_val avg_log2FC pct.1 pct.2     p_val_adj\n1 STAT1  0.000000e+00   3.536478 0.855 0.165  0.000000e+00\n2  GBP1  0.000000e+00   4.261958 0.688 0.072  0.000000e+00\n3  TAP1 6.548471e-297   2.605137 0.758 0.178 1.847127e-292\n4  GBP4 5.149525e-268   3.292704 0.642 0.087 1.452527e-263\n5  XAF1 3.277283e-251   3.115752 0.639 0.113 9.244233e-247\n\n\nAfter performing the DEA, we obtain a table listing the DEGs. Here’s what each column in the table represents:\ngene This column contains the symbols or names of the genes being analyzed.\np_val (P-value without multiple testing) The p-value represents the statistical significance of differential expression between the two groups (ident.1 and ident.2). A lower p-value indicates stronger evidence for differential expression.\navg_log2FC (Log2 fold-change) The average log2 fold-change in gene expression between the two groups. A positive value indicates upregulation in ident.1 compared to ident.2, while a negative value indicates downregulation.\npct.1 (Percentage of cells expressing the gene in ident.1) This percentage represents the proportion of cells within ident.1 that express the gene.\npct.2 (Percentage of cells expressing the gene in ident.2) Conversely, this percentage represents the proportion of cells within ident.2 that express the same gene.\np_val_adj (Adjusted p-value) After correcting for multiple testing, this adjusted p-value accounts for the increased risk of false positives. It helps control the overall false discovery rate.\n1.2 Perform DE analysis within the same cell type across conditions\nWe can also use FindMarkers to perform DEA within the same cell type across conditions. The below example shows how to find the DEGs between CD4 T cells in two conditions.\n\nfiltered$predicted.celltype.l1.tag &lt;- paste(filtered$predicted.celltype.l1, filtered$Sample_Name, sep = \"_\")\n\n# Find genes differentially expressed between activated vs. naive samples in CD4 T cells\nIdents(filtered) &lt;- \"predicted.celltype.l1.tag\"\n\ncd4t.deg &lt;- FindMarkers(filtered, \n                       ident.1 = \"CD4 T_SampleTag02_hs\", \n                       ident.2 = \"CD4 T_SampleTag01_hs\", \n                       verbose = FALSE)\n\nhead(cd4t.deg, n = 5)\n\n                 p_val avg_log2FC pct.1 pct.2     p_val_adj\nSTAT1    5.243685e-251   3.541643 0.887 0.150 1.479086e-246\nIL7R     1.388277e-199  -2.748865 0.404 0.856 3.915912e-195\nENO1     1.086061e-190   3.381945 0.772 0.208 3.063453e-186\nTAP1     2.524773e-174   2.760270 0.765 0.144 7.121627e-170\nHSP90AB1 1.010564e-172   2.587901 0.864 0.532 2.850497e-168\n\n\nCited from Seurat: “However, the p-values obtained from this analysis should be interpreted with caution, because these tests treat each cell as an independent replicate and ignore inherent correlations between cells originating from the same sample. Such analyses have been shown to find a large number of false positive associations, as has been demonstrated by Squair et al., 2021, Zimmerman et al., 2021, Junttila et al., 2022, and others. Below, we show how pseudobulking can be used to account for such within-sample correlation.”"
  },
  {
    "objectID": "07_differential_expression_analysis.html#pseudobulk-analysis",
    "href": "07_differential_expression_analysis.html#pseudobulk-analysis",
    "title": "7. Differential Expression Analysis",
    "section": "2. Pseudobulk analysis",
    "text": "2. Pseudobulk analysis\nAssume we have three biological replicates for each condition (e.g., treated and control samples). These replicates represent independent measurements of the same condition.\nWe’ll use the AggregateExpression() function to sum together gene counts for all cells within the same sample and cell type. This aggregation results in one gene expression profile per sample and cell type. Essentially, we’re creating a “pseudobulk” representation for each sample.\nNow that we have pseudobulk profiles, we can perform DEA. DESeq2 is a popular tool for this purpose. Instead of analyzing individual cells, we treat the samples (replicates) as independent observations.\nDESeq2 models the count data, accounts for biological variability, and identifies genes with significant expression differences between conditions.\n\n# make a fake group information\nfiltered$donor &lt;- sample(x = c('A', 'B', 'C'), size = ncol(filtered), replace = TRUE)\n\npseudo &lt;- AggregateExpression(filtered, assays = \"RNA\", return.seurat = T, \n                              group.by = c(\"Sample_Name\", \"donor\", \"predicted.celltype.l1\"))\n\n# perform pseudobulk\npseudo$predicted.celltype.l1.tag &lt;- paste(pseudo$predicted.celltype.l1, pseudo$Sample_Name, sep = \"_\")\n\nIdents(pseudo) &lt;- \"predicted.celltype.l1.tag\"\n\ncd4t.bulk &lt;- FindMarkers(object = pseudo, \n                         ident.1 = \"CD4 T_SampleTag02-hs\", \n                         ident.2 = \"CD4 T_SampleTag01-hs\",\n                         test.use = \"DESeq2\")\n\nhead(cd4t.bulk, n = 20)\n\n                 p_val avg_log2FC pct.1 pct.2     p_val_adj\nACTB      0.000000e+00   1.858575     1     1  0.000000e+00\nACTG1     0.000000e+00   2.514958     1     1  0.000000e+00\nENO1      0.000000e+00   3.640279     1     1  0.000000e+00\nFYB1      0.000000e+00  -2.422661     1     1  0.000000e+00\nHSP90AA1  0.000000e+00   3.279807     1     1  0.000000e+00\nHSP90AB1  0.000000e+00   3.037042     1     1  0.000000e+00\nHSPA8     0.000000e+00   2.439773     1     1  0.000000e+00\nIL7R      0.000000e+00  -3.625866     1     1  0.000000e+00\nMALAT1    0.000000e+00  -2.352007     1     1  0.000000e+00\nNPM1      0.000000e+00   1.765282     1     1  0.000000e+00\nPFN1      0.000000e+00   1.688739     1     1  0.000000e+00\nPPIA      0.000000e+00   2.053361     1     1  0.000000e+00\nPTMA      0.000000e+00   1.211173     1     1  0.000000e+00\nRAN       0.000000e+00   2.966751     1     1  0.000000e+00\nRPS27     0.000000e+00  -1.502292     1     1  0.000000e+00\nSPOCK2    0.000000e+00  -2.614261     1     1  0.000000e+00\nTPT1      0.000000e+00  -1.442488     1     1  0.000000e+00\nTUBA1B    0.000000e+00   4.057006     1     1  0.000000e+00\nTXNIP     0.000000e+00  -2.638553     1     1  0.000000e+00\nKLF2     9.629787e-303  -3.296863     1     1 2.716274e-298"
  },
  {
    "objectID": "05_clustering.html",
    "href": "05_clustering.html",
    "title": "5. Clustering",
    "section": "",
    "text": "# libraries for this chapter\nlibrary(tidyverse)\nlibrary(Seurat)\nlibrary(data.table)\nlibrary(clustree)\nlibrary(HGNChelper)"
  },
  {
    "objectID": "05_clustering.html#clustering",
    "href": "05_clustering.html#clustering",
    "title": "5. Clustering",
    "section": "1. Clustering",
    "text": "1. Clustering\nClustering is togenerate cell type-specific clusters and we can use known cell type marker genes to determine the identities of the clusters.Seurat constructs a K-nearest neighbor (KNN) graph using the Euclidean distance in PCA space FindNeighbors. Each cell is embedded in this graph, and edges connect cells with similar gene expression patterns. The goal is to partition this graph into highly interconnected groups, which we refer to as clusters.\nThe resolution is a crucial argument in the FindClusters function. It determines the granularity of the downstream clustering. Higher resolution values lead to more clusters, while lower values merge clusters.\nOptimizing resolution is essential for each experiment. The FindClusters function allows us to test different resolutions without running the function repeatedly. By providing a series of resolutions, we can assess which one works best for our analysis.\nWe first use the FindNeighbors function to determine the KNN graph, then use the FindClusters to determine the clusters for various resolutions.\n\n# Determine the K-nearest neighbor graph\nfiltered &lt;- FindNeighbors(object = filtered, dims = 1:20)\n                                \n# Determine the clusters for various resolutions                                \nfiltered &lt;- FindClusters(object = filtered,\n                         resolution = c(0.2, 0.4, 0.6,  0.8, 1, 1.2, 1.4),\n                         verbose = F)\n\nmeta.data contains a separate field for each of the different resolutions calculated during clustering. By examining these resolution-specific fields, we can determine the number of clusters associated with each resolution. This allows us to explore the granularity of clustering and choose an appropriate resolution for downstream analysis. Below is a table showing how many clusters of each resolution.\n\nfiltered@meta.data %&gt;% \n  dplyr::select(contains(\"RNA_snn\")) %&gt;% \n  map_int(~ unique(.x) %&gt;% length)\n\nRNA_snn_res.0.2 RNA_snn_res.0.4 RNA_snn_res.0.6 RNA_snn_res.0.8   RNA_snn_res.1 \n              9              12              15              16              17 \nRNA_snn_res.1.2 RNA_snn_res.1.4 \n             18              19 \n\n\nTo visualize how cells change clusters across different resolutions, we can use a tool called clustree. This tool constructs a clustering tree that shows the relationships between clusters at various resolutions.\n\nclustree(filtered, prefix = \"RNA_snn_res.\")\n\n\n\n\nSome clusters remain very distinct and do not change significantly with varying resolution. These stable clusters likely represent well-defined cell populations.\nWe observe a single cluster that splits into multiple subclusters. This suggests that within this original cluster, there are subpopulations with distinct gene expression profiles.\nAs the resolution increases, the tree becomes more complex and messy. Nodes with multiple incoming edges indicate that cells are being assigned to multiple clusters. This complexity may be a sign of overclustering—dividing the data into too many fine-grained clusters.\nWe begin by examining the clusters calculated with a resolution of 0.2.\nUsing the Identsfunction, we assign cluster identities based on this resolution.\n\nIdents(object = filtered) &lt;- \"RNA_snn_res.0.2\"\n\n# UMAP visualization\nDimPlot(filtered,\n        reduction = \"umap\",\n        label = TRUE,\n        label.size = 6)\n\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\nYou can change to other resolution values by specifying the argument group.by. How do the clusters change?\n\n# UMAP visualization\nDimPlot(filtered, \n        group.by = \"RNA_snn_res.0.4\",\n        reduction = \"umap\",\n        label = TRUE,\n        label.size = 6)"
  },
  {
    "objectID": "05_clustering.html#cell-numbers-in-each-cluster",
    "href": "05_clustering.html#cell-numbers-in-each-cluster",
    "title": "5. Clustering",
    "section": "2. Cell numbers in each cluster",
    "text": "2. Cell numbers in each cluster\nThe number of clusters obtained during graph-based clustering is highly dependent on the resolution chosen. Higher resolutions tend to create more fine-grained clusters, while lower resolutions merge clusters.\nTo visualize the cell numbers in each clusters in each sample, we can create a table.\n\nFetchData(filtered, \n          vars = c(\"ident\", \"Sample_Name\")) %&gt;%\n  dplyr::count(ident, Sample_Name) %&gt;%\n  tidyr::spread(ident, n)\n\n     Sample_Name    0   1   2   3   4   5  6  7  8\n1 SampleTag01_hs 1101   2   7 285 253  68 91 34 10\n2 SampleTag02_hs  573 916 451  11   6 178 71 59 45\n\n\nTo visualize the cell clusters in each sample, we can create a UMAP plot.\n\n# UMAP of cells in each cluster by sample\nDimPlot(filtered, \n        label = TRUE, \n        split.by = \"Sample_Name\")  + NoLegend()"
  },
  {
    "objectID": "05_clustering.html#exploring-known-cell-type-markers",
    "href": "05_clustering.html#exploring-known-cell-type-markers",
    "title": "5. Clustering",
    "section": "3. Exploring known cell type markers",
    "text": "3. Exploring known cell type markers\nWe can explore some known cell type markers to gain insights into the identities of the clusters. Here are typical cell type markers associated with specific cell populations:\nCD14+ Monocytes: CD14, LYZ\nConventional Dendritic Cells: FCER1A, CST3\nB Cells: CD79A, MS4A1\nT Cells: CD3D\nCD4+ T Cells: CD3D, IL7R, CCR7\nCD8+ T Cells: CD3D, CD8A\nNK Cells: GNLY, NKG7\nMacrophages: MARCO, ITGAM, ADGRE1\nTo visualize the expression of these known gene markers on top of our UMAP plot, we can use the FeaturePlot function. This function allows us to explore the normalized expression levels of all genes stored in the RNA assay slot of the Seurat object.\n\nDefaultAssay(filtered) &lt;- \"RNA\"\n\nCD14+ monocytes: CD14, LYZ\n\nFeaturePlot(filtered, \n            reduction = \"umap\", \n            features = c(\"CD14\", \"LYZ\"), \n            order = TRUE,\n            min.cutoff = 'q10', \n            label = TRUE)\n\n\n\n\nB cells: CD79A, MS4A1\n\nFeaturePlot(filtered, \n            reduction = \"umap\", \n            features = c(\"CD79A\", \"MS4A1\"), \n            order = TRUE,\n            min.cutoff = 'q10', \n            label = TRUE)\n\n\n\n\nNK cells: GNLY, NKG7\n\nFeaturePlot(filtered, \n            reduction = \"umap\", \n            features = c(\"GNLY\", \"NKG7\"), \n            order = TRUE,\n            min.cutoff = 'q10', \n            label = TRUE)\n\n\n\n\nT cells: CD3D\n\nFeaturePlot(filtered, \n            reduction = \"umap\", \n            features = c(\"CD3D\"), \n            order = TRUE,\n            min.cutoff = 'q10', \n            label = TRUE)\n\n\n\n\nCD4+ T cells: CD3D, IL7R, CCR7\n\nFeaturePlot(filtered, \n            reduction = \"umap\", \n            features = c(\"CD3D\", \"IL7R\", \"CCR7\"), \n            order = TRUE,\n            min.cutoff = 'q10', \n            label = TRUE)\n\n\n\n\nCD8+ T cells: CD3D, CD8A\n\nFeaturePlot(filtered, \n            reduction = \"umap\", \n            features = c(\"CD3D\", \"CD8A\"), \n            order = TRUE,\n            min.cutoff = 'q10', \n            label = TRUE)"
  },
  {
    "objectID": "03_normalization.html",
    "href": "03_normalization.html",
    "title": "3. Normalization, Scale Data and Find Highly Variable Features",
    "section": "",
    "text": "# libraries for this chapter\nlibrary(tidyverse)\nlibrary(Seurat)\nlibrary(data.table)"
  },
  {
    "objectID": "03_normalization.html#normalization",
    "href": "03_normalization.html#normalization",
    "title": "3. Normalization, Scale Data and Find Highly Variable Features",
    "section": "1. Normalization",
    "text": "1. Normalization\nAfter removing the low-quality cells during the quality control (QC) step, the next crucial step is data normalization. Normalization ensures that we can compare gene expression values across cells. A common function to normalize mRNA UMI counts is LogNormalize.\nFor each gene in a cell, we divide its UMI counts by the total UMI counts in that same cell. After this division, we take the natural logarithm of the resulting value.\nBy applying LogNormalize, we create a normalized expression matrix that allows us to perform meaningful analyses and comparisons.\n\nfiltered &lt;- NormalizeData(filtered, \n                          normalization.method = \"LogNormalize\")\n\n\n\n\n\n\n\nQuestion\n\n\n\nWhere are the normalized counts stored?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nThe below example code outputs a list of two objects.\n\nfiltered@assays[[\"RNA\"]]@layers\n\n\n\ncounts (Unnormalized Data)\n\nThis object contains the raw UMI counts for each gene in each cell. The counts are represented as integers (whole numbers). These unnormalized counts reflect the original data without any adjustments.\n\n\ndata (Normalized Data)\n\nThe “data” object contains the normalized expression values for each gene in each cell. Unlike the raw counts, these normalized values are represented as decimals (floating-point numbers)."
  },
  {
    "objectID": "03_normalization.html#scale-data",
    "href": "03_normalization.html#scale-data",
    "title": "3. Normalization, Scale Data and Find Highly Variable Features",
    "section": "2. Scale data",
    "text": "2. Scale data\nNormalizing the data ensures that expression values are comparable across cells. Data scaling is the next step. Its purpose is to remove bias introduced by highly expressed genes. This step is necessary for principal component analysis (PCA) calculations.\n\n# Scale data\nfiltered &lt;- ScaleData(filtered, features = rownames(filtered))\n\n\n\n\n\n\n\nQuestion\n\n\n\nWhere are the scaled counts stored?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nThe scaled counts are stored in the scale.data layer of assay RNA.\n\nfiltered@assays[[\"RNA\"]]@layers[[\"scale.data\"]]"
  },
  {
    "objectID": "03_normalization.html#find-variable-features",
    "href": "03_normalization.html#find-variable-features",
    "title": "3. Normalization, Scale Data and Find Highly Variable Features",
    "section": "3. Find variable features",
    "text": "3. Find variable features\nWe assume that the biological differences between cells are reflected in the genes that exhibit variability across the entire cell population. To focus on these variable genes, we select only the top variable features (genes) for further analysis. By default, the function FindVariableFeatures identifies and returns the top 2000 variable genes.\nYou can choose to run FindVariableFeatures first and then proceed with ScaleData. The sequence of these two functions does not impact the overall analysis.\n\n# Find variable features\nfiltered &lt;- FindVariableFeatures(filtered)\n\n# Identify the 10 most highly variable genes\ntop10 &lt;- head(VariableFeatures(filtered), 10)\n\n# plot variable features with and without labels\nplot1 &lt;- VariableFeaturePlot(filtered) + theme(legend.position = \"none\")\nplot2 &lt;- LabelPoints(plot = plot1, points = top10, repel = TRUE)\nplot1 + plot2"
  },
  {
    "objectID": "01_data_import.html",
    "href": "01_data_import.html",
    "title": "1. Data Import",
    "section": "",
    "text": "# libraries for this chapter\nlibrary(tidyverse)\nlibrary(Seurat)\nlibrary(data.table)"
  },
  {
    "objectID": "01_data_import.html#demo-data-description",
    "href": "01_data_import.html#demo-data-description",
    "title": "1. Data Import",
    "section": "Demo data description",
    "text": "Demo data description\nThe demo data is generated from freshly isolated human PBMCs. The PBMCs were grown for 24 hours in the presence of CD3/CD28 stimulation (“treated”) and compared to PBMCs grown for 24 hours in regular media (“naive”). Cells were then labeled with a 20 plex AbSeq panel consisting of lineage markers and T-cell activation markers, as well as unique Sample Tags from the BD Rhapsody™ Human Single Cell Multiplexing Kit (resting PBMC: ST1; treated PBMC: ST2). The cells were mixed at a 1:1 ratio and processed using the BD Rhapsody™ Single-Cell Analysis System. Sequencing libraries for RNA and AbSeq antibodies were generated using the BD Rhapsody WTA Amplification kit."
  },
  {
    "objectID": "01_data_import.html#import-expression-matrix-into-rstudio",
    "href": "01_data_import.html#import-expression-matrix-into-rstudio",
    "title": "1. Data Import",
    "section": "1. Import expression matrix into RStudio",
    "text": "1. Import expression matrix into RStudio\nRhapsody single cell primary pipeline outputs a rds file containing the expression matrix as a Seurat object. The Seurat object stores the unique molecular identifier (UMI) counts of a feature (gene or AbSeq).\nTo import the rds file containing the expression matrix as a Seurat object, we can use the readRDS() function and store it in a variable called seuratObj.\n\nseuratObj &lt;- readRDS(\"processed_BD-Demo-WTA-AbSeq-SMK_Seurat.rds\")\n\nTo view the structure of a Seurat object (seuratObj) in RStudio, you can use the View() function.\n\nView(seuratObj)\n\nIt will open a new tab with a spreadsheet-like view of the seuratObj`s structure, allowing you to explore its components and their values. Example below:\n\n\nassays\n\nseuratObj contains two assays: RNA and ADT. RNA stores Gene Expression; ADT stores AbSeq. Seurat v5 assays store data in layers. These layers can store raw, un-normalized counts (layer=‘counts’), normalized data (layer=‘data’), or z-scored/variance-stabilized data (layer=‘scale.data’).\n\nmeta.data\n\nmeta.data stores information of each cell. It contains below information:\norig.ident Sample identity or sample name. By default, it is “SeuratProject”.\nnCount_RNA UMI counts per gene per cell.\nnFeature_RNA Genes counts per cell.\nCell_Type_Experiment Cell annotation based on 100 marker genes of immune cell types.\nSample_Tag The cell is from which sample tag.\nSample_Name The cell is from which sample.\nPutative_Cell_Algorithm Which algorithm is used to call the cell. Default is “Basic”.\nnCount_ADT UMI counts per AbSeq per cell.\nnFeature_ADT AbSeq counts per cell.\n\nactive.assay\n\nThe active.assay in a Seurat object indicates which assay is currently active. When performing functions on a Seurat object, the functions will use the counts of the active assay. By default, the active assay is set to “RNA”. However, if you want to apply functions on the “ADT” assay, you need to switch active assay to “ADT” or specify within the function that it should use the counts from “ADT”."
  },
  {
    "objectID": "01_data_import.html#update-seurat-object",
    "href": "01_data_import.html#update-seurat-object",
    "title": "1. Data Import",
    "section": "2. Update Seurat object",
    "text": "2. Update Seurat object\nSeurat was updated from version 4 (v4) to version 5 (v5) in October 2023. If you have a Seurat object that was created with v4, it is important to update it v5. This is because there are slight differences in the functions between the two versions. To update your Seurat object to version , you can follow the below steps.\n\nseuratObj[[\"RNA\"]] &lt;- as(object = seuratObj[[\"RNA\"]], Class = \"Assay5\")\nseuratObj[[\"ADT\"]] &lt;- as(object = seuratObj[[\"ADT\"]], Class = \"Assay5\")\n\nTo determine the version of a Seurat object, refer to the seuratObj. By clicking on seuratObj in the Environment, a popup window will display the data structure of the Seurat object. The version of the Seurat object can be identified by checking if it mentions “Assay5” for v5 or “Assay4” for other versions. Example below:"
  },
  {
    "objectID": "00_about.html",
    "href": "00_about.html",
    "title": "Introduction",
    "section": "",
    "text": "This repository contains the teaching materials of Single Cell Boot Camp - Analyzing scRNA-seq with R. The boot camp aims to provide an overview of scRNAseq analysis workflow. It begins with a fast-paced session on the analysis workflow and proceeds with hands-on practice using bioinformatics packages such as Seurat."
  },
  {
    "objectID": "00_about.html#prerequisites-to-attend-the-single-cell-boot-camp",
    "href": "00_about.html#prerequisites-to-attend-the-single-cell-boot-camp",
    "title": "Introduction",
    "section": "Prerequisites to attend the Single Cell Boot Camp",
    "text": "Prerequisites to attend the Single Cell Boot Camp\nEach participant are expected to have:\nThe following statistical concepts:\n\nmedian: A measure of central tendency that represents the middle value in a dataset when arranged in ascending order.\nlog2 fold change: A measure used in gene expression analysis to quantify the difference in expression levels between two conditions.\np-value: A statistical measure that helps determine the significance of a result in the context of a hypothesis test.\nadjusted p-value: A corrected p-value that accounts for multiple comparisons to control for false positive.\nvariance: A measure of how much the values in a dataset deviate from the mean.\nprincipal component analysis (PCA): A technique used to reduce the dimensionality of high-dimensional data while capturing most of its variance.\n\nAdditionally, participants should have a basic understanding of R and the tidyverse package. Familiarity with the following functions will be useful:\n\n%&gt;% (pipe): Allows for chaining multiple operations together.\nfilter: Selects specific rows from a dataset on given conditions.\nmutate: Adds new variables or modifies existing ones in a dataset.\nselect: Selects specific columns from a dataset.\nleft_join: Merges two datasets based on a common key, keeping only the matching records from the left dataset.\n\nFor self-learning of R programming and the tidyverse package, it is recommended study Chapter 1 - 4 from MordernDive."
  },
  {
    "objectID": "00_about.html#expected-outcome",
    "href": "00_about.html#expected-outcome",
    "title": "Introduction",
    "section": "Expected outcome",
    "text": "Expected outcome\nBy the end of the workshop, participants will have a solid understanding of the analysis workflow involved in single cell analysis. This includes data pre-processing, quality control, normalization, dimentionality reduction, clustering, and cell type annotation."
  },
  {
    "objectID": "00_about.html#reference",
    "href": "00_about.html#reference",
    "title": "Introduction",
    "section": "Reference",
    "text": "Reference\nThe building of materials references and relies on many excellent and well-written public available materials. Some of the main references for the course include:\n\nSeurat https://satijalab.org/seurat/\nSingle Cell Best Practices: https://www.sc-best-practices.org/preamble.html\nOrchestrating Single-Cell Analysis with Bioconductor: https://bioconductor.org/books/release/OSCA/\nMary Piper, Meeta Mistry, Jihe Liu, William Gammerdinger, & Radhika Khetani. (2022, January 6). hbctraining/scRNA-seq_online: scRNA-seq Lessons from HCBC (first release). Zenodo. https://doi.org/10.5281/zenodo.5826256"
  },
  {
    "objectID": "00_about.html#reporting-bugs",
    "href": "00_about.html#reporting-bugs",
    "title": "Introduction",
    "section": "Reporting bugs",
    "text": "Reporting bugs\nTo report any bugs, please create an issue in the following GitHub repository: https://github.com/material-share/material-share-single-cell-boot-camp/issues."
  },
  {
    "objectID": "00_about.html#disclaimer",
    "href": "00_about.html#disclaimer",
    "title": "Introduction",
    "section": "Disclaimer",
    "text": "Disclaimer\nRecommendations given by representatives of BD in the context of the creation and setup of customer-specific applications and assays, the composition of antibody panels and suggestions for data analysis are provided in a diligent manner. However, the Customer acknowledges that (i) such recommendations should not be treated as a substitute for the Customer’s own examination, (ii) BD does not make any promises nor guarantees that recommendations are accurate and complete and will meet the Customer’s present or future needs or will produce positive or specific results and (iii) Customer remains solely responsible for validating and deciding on any such recommendations.\nBD therefore accepts no liability whatsoever in connection with any such recommendation and/or any results generated on the basis of such recommendations and, to the fullest extent permitted by law, expressly disclaims any and all warranties and any liability in this respect. In particular, the Customer assumes sole responsibility for the validation, use, selection, and suitability of the recommendations for its needs and objectives."
  },
  {
    "objectID": "00_about.html#license",
    "href": "00_about.html#license",
    "title": "Introduction",
    "section": "License",
    "text": "License\nMIT License\nCopyright (c) 2023 material-share\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
  },
  {
    "objectID": "00_setup.html",
    "href": "00_setup.html",
    "title": "Setup R and RStudio on Desktop",
    "section": "",
    "text": "To gain a better understanding of programming language R and the single cell analysis workflow, it is highly recommended to download the GitHub materials and practice them on your own desktop before the Single Cell Boot Camp. We have found that individuals who go through the material tend to have a much more successful learning experience."
  },
  {
    "objectID": "00_setup.html#how-to-prepare-the-single-cell-boot-camp",
    "href": "00_setup.html#how-to-prepare-the-single-cell-boot-camp",
    "title": "Setup R and RStudio on Desktop",
    "section": "",
    "text": "To gain a better understanding of programming language R and the single cell analysis workflow, it is highly recommended to download the GitHub materials and practice them on your own desktop before the Single Cell Boot Camp. We have found that individuals who go through the material tend to have a much more successful learning experience."
  },
  {
    "objectID": "00_setup.html#download-materials-from-the-github-page",
    "href": "00_setup.html#download-materials-from-the-github-page",
    "title": "Setup R and RStudio on Desktop",
    "section": "1. Download materials from the Github page",
    "text": "1. Download materials from the Github page\nVisit GitHub repository: https://github.com/material-share/material-share-single-cell-boot-camp\nClick on Code.\nSelect Download ZIP in the drop down menu (Example below).\n\nUnzip the downloaded file.\nIf you do not have R and RStudio on your desktop, please follow the next section to set up R and RStudio."
  },
  {
    "objectID": "00_setup.html#set-up-r-and-rstudio",
    "href": "00_setup.html#set-up-r-and-rstudio",
    "title": "Setup R and RStudio on Desktop",
    "section": "2. Set up R and RStudio",
    "text": "2. Set up R and RStudio\nHere are the steps to set up the most up-to-date R and RStudio on your desktop:\n\nGo to the RStudio website at https://posit.co/download/rstudio-desktop/.\n\nDownload and install R.\nDownload the RStudio Desktop for your operating system (Windows, Mac, or Linux) by clicking on the appropriate link.\nOnce the download is complete, double-click the downloaded file to start the installation process.\nFollow the installation instructions provided by the RStudio installer.\nAfter RStudio is installed, open the RStudio application.\nRStudio should automatically detect an existing installation of R on your system. If not, you may be prompted to select the path to the R executable file.\nOnce R is detected or selected, RStudio will launch and you will see the RStudio IDE (Integrated Development Environment) with the R console.\nYou are now ready to start using R and RStudio on your desktop.\n\nNow that you have R and RStudio set up, you can follow the next section to install the R packages."
  },
  {
    "objectID": "00_setup.html#install-r-packages",
    "href": "00_setup.html#install-r-packages",
    "title": "Setup R and RStudio on Desktop",
    "section": "3. Install R packages",
    "text": "3. Install R packages\nONLY for windows machines: If you are working on Windows, please first download and install RTools from https://cran.r-project.org/bin/windows/Rtools/.\nMac users can proceed directly.\n\nOpen RStudio.\n\nExecute the following commands one by one in the Console. Wait for each installation to finish before moving on to the next command.\n\n\ninstall.packages(\"tidyverse\")\n\ninstall.packages(\"Matrix\")\n\ninstall.packages(\"RCurl\")\n\ninstall.packages(\"scales\")\n\ninstall.packages(\"data.table\")\n\ninstall.packages(\"readxl\")\n\ninstall.packages(\"BiocManager\")\n\ninstall.packages(\"ggpubr\")\n\ninstall.packages(\"Seurat\")\n\nBiocManager::install(\"ensembldb\")\n\nBiocManager::install(\"org.Hs.eg.db\")\n\nBiocManager::install(\"clusterProfiler\")\n\nBiocManager::install(\"AnnotationDbi\")\n\nBiocManager::install(\"biomaRt\")\n\nBiocManager::install(\"enrichplot\")\n\nBiocManager::install(\"HGNChelper\")\n\n\nCheck that all the packages were installed successfully by loading them one by one at a time in the Console using the library() function.\n\n\nlibrary(tidyverse)\nlibrary(Seurat)\nlibrary(BiocManager)\nlibrary(Matrix)\nlibrary(RCurl)\nlibrary(readxl)\nlibrary(scales)\nlibrary(ggpubr)\nlibrary(data.table)\nlibrary(AnnotationHub)\nlibrary(ensembldb)\nlibrary(HGNChelper)\nlibrary(clusterProfiler)\nlibrary(AnnotationDbi)\nlibrary(biomaRt)\nlibrary(enrichplot)\n\nNow that you have R, RStudio and R packages set up, you can follow the next chapter to practice on the materials.\nTo start practicing, go to the download folder, and double click single-cell-boot-camp.Rproj."
  },
  {
    "objectID": "00_setup.html#reporting-bugs",
    "href": "00_setup.html#reporting-bugs",
    "title": "Setup R and RStudio on Desktop",
    "section": "4. Reporting bugs",
    "text": "4. Reporting bugs\nTo report any bugs, please create an issue in the following GitHub repository: https://github.com/material-share/material-share-single-cell-boot-camp/issues."
  },
  {
    "objectID": "02_quality_control.html",
    "href": "02_quality_control.html",
    "title": "2. Quality Control",
    "section": "",
    "text": "# libraries for this chapter\nlibrary(tidyverse)\nlibrary(Seurat)\nlibrary(data.table)\nThe single-cell dataset may contain low-quality cells, such as those that are dead. These low-quality cells are characterized by low UMI counts, low gene counts, and a high mitochondrial percentage. To filter out these low-quality cells, we can determine appropriate cutoff based on the distribution of these metrics."
  },
  {
    "objectID": "02_quality_control.html#sample-multiplexing-kit-smk",
    "href": "02_quality_control.html#sample-multiplexing-kit-smk",
    "title": "2. Quality Control",
    "section": "1. Sample Multiplexing Kit (SMK)",
    "text": "1. Sample Multiplexing Kit (SMK)\nIn an experiment that utilizes the Sample Multiplexing Kit (SMK) for multiplexing samples, it is expected that some cells will be identified as “Multiplets” and “Undetermined”.\n\n\n\n\n\n\nImportant\n\n\n\nMultiplets and Undetermined in SMK\nThe concept of multiplets in SMK is different from the idea of duplets in which one microwell contains two cells. Multiplets in SMK kits can include both traditional duplets, as well as singlets where cell has two SMK tags.\nThe Undetermined refers to cell labels that have zero or very low SMK tag reads detected. These can be either noisy cell labels or singlets that are not labeled with SMK tags.\n\n\nTo visualize the number of cells in each SMK tag, we can use a bar plot. By visualizing the number of cells in each SMK tag using a bar plot, we can gain insights into the distribution of cells across different tags.\n\nseuratObj@meta.data %&gt;% \n  group_by(Sample_Name) %&gt;% \n  tally(name = \"cell_count\") %&gt;% \n  ggplot(aes(x=Sample_Name, y=cell_count, fill= Sample_Name)) + \n  geom_bar(stat = \"identity\") +\n  geom_text(aes(y = cell_count,\n                label = cell_count,\n                vjust= -0.5, size = 2.5), show.legend = FALSE) + \n  theme_classic() +\n  theme(axis.title.x=element_blank(),\n        legend.position = \"none\")\n\n\n\n\nAccording to the bar plot, most of the cells are either in Sample Tag 01 or Sample Tag 02. However, there are some cells labeled as Multiplet or Undetermined which cannot be assigned to either sample tag. To exclude these Multiplets and Undetermined cells from further analysis, we can use the subset function. This function will allow us to remove the unwanted cells and focus only on the cells belonging to Sample Tag 01 or Sample Tag 02.\n\nseuratObj &lt;- subset(seuratObj, \n                    subset = Sample_Name %in% c(\"Multiplet\", \"Undetermined\"), \n                    invert = T)"
  },
  {
    "objectID": "02_quality_control.html#assessing-quality-metrics",
    "href": "02_quality_control.html#assessing-quality-metrics",
    "title": "2. Quality Control",
    "section": "2. Assessing quality metrics",
    "text": "2. Assessing quality metrics\nTo identify cells of low quality, we will use the quality metrics such as nCount_RNA, nFeature_RNA, and mitochondrial percentage. We will determine which cells should be considered of low quality and exclude them from further analysis.\n2.1 nCount_RNA UMI counts per cell\nThe term nCount_RNA refers to the UMI counts per cell.\nWe create two plots side by side: a ridge plot and a violin plot. These plots are organized by samples. By observing the ridge plot, we notice the presence of two distinct peaks. This indicates that there are at least two cell populations within the dataset, each with a different transcriptome size.\n\np1 &lt;- seuratObj@meta.data %&gt;% \n  ggplot(aes(color=Sample_Name, x=nCount_RNA, fill= Sample_Name)) + \n  geom_density(alpha = 0.2) + \n  scale_x_log10() + \n  theme_classic()\n\np2 &lt;- VlnPlot(seuratObj, features = \"nCount_RNA\", split.by = \"Sample_Name\") +\n  scale_y_log10()\n\np1|p2\n\n\n\n\n2.2 nFeature_RNA Gene counts per cell\nThe term nFeature_RNA refers to the gene counts per cell.\nOnce again, we generate two plots side by side: a ridge plot and a violin plot. These plots are organized by samples. In our analysis, we focus on the sum of gene counts per cell using the nFeature_RNA metric. Notably, the majority of cells have gene counts above 300.\n\np1 &lt;- seuratObj@meta.data %&gt;% \n  ggplot(aes(color=Sample_Name, x=nFeature_RNA, fill= Sample_Name)) + \n  geom_density(alpha = 0.2) + \n  scale_x_log10() + \n  theme_classic()\n\np2 &lt;- VlnPlot(seuratObj, features = \"nFeature_RNA\", split.by = \"Sample_Name\") +\n  scale_y_log10()\n\np1|p2\n\n\n\n\n2.3 Mitochondrial percentage\nWhen you create a Seurat object, Seurat automatically generates some metadata for each cell. These metadata are stored in the meta.data. You can use the metadata to filter out low-quality cells. Specifically, the metadata includes two columns: nCount_RNA and nFeature_RNA. However, it does not include information on mitochondrial percentage.\nBefore proceeding, it’s essential to calculate the mitochondrial percentage for each cell. Fortunately, Seurat provides a convenient function called PercentageFeatureSet that allows you to compute the percentage of UMIs associated with mitochondrial genes in a cell.\n\nseuratObj[[\"percent.mt\"]] &lt;- PercentageFeatureSet(seuratObj, pattern = \"^MT-\")\n\n\n\n\n\n\n\nTip\n\n\n\nTo ensure correct calculation of the mitochondrial percentage, it’s essential to consider the variations in mitochondrial gene names across different genome versions. You can use the grep command to examine the gene name patterns associated with mitochondrial genes.\nFor instance, in the demo dataset, mitochondrial genes typically begin with the prefix “MT-”. By identifying this consistent pattern, you can confidently calculate the mitochondrial percentage for each cell.\n\ngrep(pattern = \"mt-\", rownames(seuratObj), ignore.case = T, value = T)\n\n\n\nThe PercentageFeatureSet function accepts a pattern argument and scans through all feature names in the dataset for that specific pattern. In our case, we are interested in mitochondrial genes, so we search for any gene names that begin with the typical pattern associated with mitochondrial genes.\nFor each cell, the function calculates the sum of counts across all genes that belong to mitochondrial genes. It then divides this sum by the total counts for all genes in that cell. The resulting value is stored in the percent.mt field within the meta.data.\nWhen examining the mitochondrial percentage per cell, we observe that the majority of cells have a mitochondrial percentage below 25%.\n\np1 &lt;- seuratObj@meta.data %&gt;% \n  ggplot(aes(color=Sample_Name, x=percent.mt, fill=Sample_Name)) + \n  geom_density(alpha = 0.2) + \n  theme_classic()\n\np2 &lt;- VlnPlot(seuratObj, features = \"percent.mt\", split.by = \"Sample_Name\")\n\np1|p2\n\n\n\n\n2.4 Combine metrics\nTo determine the filtering threshold, we can combine the following metrics: nCount_RNA, nFeature_RNA, and percent.mt. By considering these factors together, we can make informed decisions about cell quality and inclusion in our analysis.\n\nseuratObj@meta.data %&gt;% \n  ggplot(aes(x=nCount_RNA, y=nFeature_RNA, color=percent.mt)) + \n  geom_point() + \n  scale_colour_gradient(low = \"gray90\", high = \"black\") +\n  stat_smooth(method=lm) +\n  scale_x_log10() + \n  scale_y_log10() + \n  theme_classic() +\n  geom_vline(xintercept = 500, colour = \"red\") +\n  geom_hline(yintercept = 300, colour = \"red\") +\n  facet_wrap(~Sample_Name) +\n  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))\n\n\n\n\nThe data is fitted with a linear regression line. We expect that as UMI counts increase, gene counts will also increase.\nQuadrants:\n\nUpper Right Quadrant: Cells in this quadrant exhibit both high gene counts and high UMI counts. These cells are generally considered to be of good quality.\nBottom Right Quadrant: Cells in this quadrant have low gene counts and low UMI counts. These cells are typically considered to be of low quality.\n\nDarker Cells:\n\nThe darker cells represent cells with a high mitochondrial percentage. Interestingly, many of these cells also have low gene counts. This observation may indicate that these cells are damaged or dying.\nOne possible explanation is that the cytoplasmic mRNA in these cells is leaking out through a broken membrane. As a result, only the mRNA located in the mitochondria remains conserved."
  },
  {
    "objectID": "02_quality_control.html#filter-out-low-quality-cells",
    "href": "02_quality_control.html#filter-out-low-quality-cells",
    "title": "2. Quality Control",
    "section": "4. Filter out low quality cells",
    "text": "4. Filter out low quality cells\nLet’s summarize the quality thresholds for filtering out low-quality cells based on the provided metrics:\nnCount_RNA Cells with UMI counts greater than 500 are considered acceptable.\nnFeature_RNA Cells with gene counts greater than 300 and less than 5000 fall within the desired range.\npercent.mt Cells with a mitochondrial percentage below 25% are preferred.\nBy applying these thresholds, we can effectively filter out cells that do not meet the quality criteria.\n\nfiltered &lt;- subset(x = seuratObj, \n                       subset = (nCount_RNA &gt;= 500) & \n                         (nFeature_RNA &gt;= 300) &\n                         (nFeature_RNA &lt;= 5000) &\n                         (percent.mt &lt; 25))"
  },
  {
    "objectID": "02_quality_control.html#re-assess-metrics",
    "href": "02_quality_control.html#re-assess-metrics",
    "title": "2. Quality Control",
    "section": "5. Re-assess metrics",
    "text": "5. Re-assess metrics\nAfter applying the filtering criteria, it’s essential to verify that the filtered data aligns with our expectations. To do so, we revisit the quality control (QC) metrics and create plots using the filtered dataset. These updated plots will help us assess the quality of the remaining cells.\n\np1 &lt;- filtered@meta.data %&gt;% \n  ggplot(aes(color=Sample_Name, x=nCount_RNA, fill= Sample_Name)) + \n  geom_density(alpha = 0.2) + \n  scale_x_log10() + \n  theme_classic()\n\np2 &lt;- VlnPlot(filtered, features = \"nCount_RNA\", split.by = \"Sample_Name\") +\n  scale_y_log10()\n\np1|p2\n\n\n\n\n\np1 &lt;- filtered@meta.data %&gt;% \n  ggplot(aes(color=Sample_Name, x=nFeature_RNA, fill= Sample_Name)) + \n  geom_density(alpha = 0.2) + \n  scale_x_log10() + \n  theme_classic()\n\np2 &lt;- VlnPlot(filtered, features = \"nFeature_RNA\", split.by = \"Sample_Name\") +\n  scale_y_log10()\n\np1|p2\n\n\n\n\n\np1 &lt;- filtered@meta.data %&gt;% \n  ggplot(aes(color=Sample_Name, x=percent.mt, fill=Sample_Name)) + \n  geom_density(alpha = 0.2) + \n  theme_classic()\n\np2 &lt;- VlnPlot(filtered, features = \"percent.mt\", split.by = \"Sample_Name\")\n\np1|p2\n\n\n\n\n\nfiltered@meta.data %&gt;% \n  ggplot(aes(x=nCount_RNA, y=nFeature_RNA, color=percent.mt)) + \n  geom_point() + \n  scale_colour_gradient(low = \"gray90\", high = \"black\") +\n  stat_smooth(method=lm) +\n  scale_x_log10() + \n  scale_y_log10() + \n  theme_classic() +\n  geom_vline(xintercept = 500, color = \"red\") +\n  geom_hline(yintercept = 300, color = \"red\") +\n  facet_wrap(~Sample_Name)\n\n\n\n\nFrom the QC plots, we can see low-quality cells from the bottom right quadrant are removed. We can also compare the cell count before and after filtering. The majority of cells are retained even after applying the quality filters.\nBefore filtering:\n\nseuratObj@meta.data %&gt;% \n  group_by(Sample_Name) %&gt;% \n  dplyr::summarise(cell_number = length(Sample_Name))\n\n# A tibble: 2 × 2\n  Sample_Name    cell_number\n  &lt;chr&gt;                &lt;int&gt;\n1 SampleTag01_hs        2113\n2 SampleTag02_hs        2846\n\n\nAfter filtering:\n\nfiltered@meta.data %&gt;% \n  group_by(Sample_Name) %&gt;% \n  dplyr::summarise(cell_number = length(Sample_Name))\n\n# A tibble: 2 × 2\n  Sample_Name    cell_number\n  &lt;chr&gt;                &lt;int&gt;\n1 SampleTag01_hs        1851\n2 SampleTag02_hs        2310"
  },
  {
    "objectID": "04_pca_umap.html",
    "href": "04_pca_umap.html",
    "title": "4. PCA and UMAP",
    "section": "",
    "text": "# libraries for this chapter\nlibrary(tidyverse)\nlibrary(Seurat)\nlibrary(data.table)"
  },
  {
    "objectID": "04_pca_umap.html#principal-component-analysis-pca",
    "href": "04_pca_umap.html#principal-component-analysis-pca",
    "title": "4. PCA and UMAP",
    "section": "1. Principal Component Analysis (PCA)",
    "text": "1. Principal Component Analysis (PCA)\nPCA is a dimensionality reduction technique that transforms our data into a new set of orthogonal axes (principal components or PCs). Each PC captures a certain degree of variance in the original data. The first PC explains the most variance, followed by subsequent PCs.\nTo understand how many PCs to retain for downstream analysis, we create an Elbow plot. The x-axis represents the number of PCs, and the y-axis shows the cumulative variance explained. As we add more PCs, the cumulative variance explained gradually increases. The “elbow point” on the plot indicates the optimal number of PCs to retain (where additional PCs contribute less to the overall variance).\nPCA helps to reduce dimensionality while retaining meaningful information, and the Elbow plot guides us in selecting the appropriate number of PCs for downstream analyses.\nWe first use the function RunPCA to calculate principal components, then use ElbowPlot to create an elbow plot to select the number of PCs for downstream analyses.\n\nfiltered &lt;- RunPCA(filtered, npcs = 50, verbose = FALSE)\n\n\nElbowPlot(filtered, ndims = 50)\n\n\n\n\nThe Elbow plot gets its name from its distinctive shape, resembling an elbow.\nThe top PCs (usually the first few) explain a significant degree of variance in the data. This variance is often biologically relevant, capturing essential information about cell heterogeneity or gene expression patterns.\nAs we move down the list of PCs, the biological variance they explain gradually decreases. However, there’s an important consideration: technical variance. Technical variance includes noise, batch effects, and other technical artifacts. The further down the PCs, the higher the chance of technical variance (noise, batch effects, etc.) dominating the signal.\nWhile the top PCs are crucial for understanding biological differences, we must strike a balance to avoid overfitting to technical noise. A rule of thumb is to look for where the elbow is in the elbow plot.\n\n\n\n\n\n\nTip\n\n\n\nIf you’re interested in a step-by-step calculation of PCA, please take a look on this YouTube video created by Josh Starmer. In this video, Josh Starmer breaks down the concept and procedure of PCA using Singular Value Decomposition (SVD). He demonstrates how PCA reduces data dimensionality, identifies important variables for clustering, and interprets eigenvalues, eigenvectors, loading scores, and scree plots."
  },
  {
    "objectID": "04_pca_umap.html#uniform-manifold-approximation-and-projection-umap",
    "href": "04_pca_umap.html#uniform-manifold-approximation-and-projection-umap",
    "title": "4. PCA and UMAP",
    "section": "2. Uniform Manifold Approximation and Projection (UMAP)\n",
    "text": "2. Uniform Manifold Approximation and Projection (UMAP)\n\nUMAP is an algorithm specifically designed for dimensionality reduction. Its primary purpose is to transform a high-dimensional dataset (such as scRNA data) into a low-dimensional plot while preserving essential information. In scRNA-seq, each cell is characterized by thousands of gene expression counts. UMAP simplifies this complexity by creating a two-dimensional plot, which we refer to as a UMAP plot.\nUMAP requires the top principal components as input. These PCs are obtained from the earlier step of PCA.\nThe choice of how many top PCs to include significantly impacts downstream analyses. An arbitrary yet effective approach is to examine the Elbow plot. Look for the point on the plot where the cumulative variance explained starts to level off (often resembling an “elbow”). This point indicates the optimal number of PCs to retain.\n\n\n\n\n\n\nImportant\n\n\n\nRetaining too few PCs may lose important biological information, while including too many may introduce noise.\n\n\nIn this specific example, we’ll use the first 20 PCs for downstream analysis (e.g., calculating UMAP).\n\nfiltered &lt;- RunUMAP(filtered, \n                    reduction = \"pca\", \n                    dims = 1:20)\n\n# Plot UMAP                             \nDimPlot(filtered, group.by = \"Sample_Name\")"
  },
  {
    "objectID": "04_pca_umap.html#exercise-1",
    "href": "04_pca_umap.html#exercise-1",
    "title": "4. PCA and UMAP",
    "section": "Exercise 1",
    "text": "Exercise 1\nChange the number of PCs and see how the UMAP changes.\nTips: You can change the PC numbers by dims argument in RunUMAP."
  },
  {
    "objectID": "04_pca_umap.html#exercise-2",
    "href": "04_pca_umap.html#exercise-2",
    "title": "4. PCA and UMAP",
    "section": "Exercise 2",
    "text": "Exercise 2\nDimplot has many arguments to control the plots.\n\nSearch Dimplot in the “Help” tab and read the documentation.\nChange group.by to split.by. What is the difference?"
  },
  {
    "objectID": "06_ident_marker.html",
    "href": "06_ident_marker.html",
    "title": "6. Marker Identification",
    "section": "",
    "text": "# libraries for this chapter\nlibrary(tidyverse)\nlibrary(Seurat)\nlibrary(data.table)\nlibrary(HGNChelper)\nAfter performing clustering, we identify distinct clusters of cells. To label these clusters, we often examine known marker genes on a UMAP plot. These marker genes are highly expressed in specific clusters, allowing us to differentiate them from others.\nAdditionally, we can perform gene expression comparisons to identify genes that exhibit significant expression differences between clusters. By analyzing gene expression levels, we can pinpoint which genes are uniquely associated with a particular cluster."
  },
  {
    "objectID": "06_ident_marker.html#find-marker-genes",
    "href": "06_ident_marker.html#find-marker-genes",
    "title": "6. Marker Identification",
    "section": "1. Find marker genes",
    "text": "1. Find marker genes\n1.1 FindAllMarkers\n\nThe FindAllMarkers function is typically used for evaluating a single sample group or condition. With this function, we compare each cluster to all other clusters to identify potential marker genes. The cells within each cluster are treated as replicates, and a differential expression analysis is performed using some statistical test. By default, the test used is the Wilcoxon Rank Sum test.\nThe function has three important arguments for determining whether a gene is a marker gene:\nlogfc.threshold: This argument limits testing to genes that show, on average, at least an X-fold difference (log-scale) between the two groups of cells. The default value is 0.25. Increasing this threshold can speed up the function but may miss weaker signals.\nmin.pct: Only genes detected in a minimum fraction of cells in either of the two populations are tested. This argument helps speed up the function by excluding infrequently expressed genes. The default value is 0.1.\nonly.pos: By default, the function returns both positive and negative markers. However, if you set this argument to TRUE, it will only return positive markers.\nDepending on your specific requirements, you can adjust these arguments to be more or less stringent.\nIn the below example, we look at the marker genes in the clusters in one sample “treated” (PBMC with CD3/CD28 stimulation).\n\ntreated.markers &lt;- FindAllMarkers(subset(filtered, subset = Sample_Name == \"SampleTag02_hs\"), \n                                  assay = \"RNA\",\n                                  only.pos = TRUE, \n                                  min.pct = 0.25, \n                                  logfc.threshold = 0.25)\n\nLet’s look at the top 2 significant marker genes in each cluster.\n\ntreated.markers %&gt;%\n    group_by(cluster) %&gt;%\n    slice_max(n = 2, order_by = avg_log2FC)\n\n# A tibble: 18 × 7\n# Groups:   cluster [9]\n       p_val avg_log2FC pct.1 pct.2 p_val_adj cluster gene     \n       &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt; &lt;fct&gt;   &lt;chr&gt;    \n 1 2.79e- 99       7.17 0.271 0.007 7.88e- 95 0       NSMCE1-DT\n 2 1.49e-163       3.62 0.719 0.2   4.20e-159 0       MAL      \n 3 1.27e- 92       4.68 0.296 0.009 3.60e- 88 1       EXO1     \n 4 7.51e-184       4.39 0.555 0.025 2.12e-179 1       SLC29A1  \n 5 0               7.59 0.876 0.018 0         2       GNLY     \n 6 0               7.15 0.86  0.026 0         2       PRF1     \n 7 0              16.1  0.727 0     0         3       CCL24    \n 8 1.31e-229      12.4  0.455 0     3.71e-225 3       CXCL3    \n 9 5.71e-  6       6.20 0.333 0.029 1.61e-  1 4       H1-3     \n10 1.48e-  6       6.14 0.333 0.026 4.18e-  2 4       ZNF8     \n11 0              10.8  0.888 0.007 0         5       IGHM     \n12 2.96e-230      10.8  0.556 0.008 8.34e-226 5       IGKC     \n13 1.61e-238      13.4  0.479 0     4.54e-234 6       CEACAM8  \n14 1.82e-231      12.8  0.465 0     5.12e-227 6       PADI2    \n15 0              13.1  0.898 0.002 0         7       GCSAML   \n16 1.21e-280      12.5  0.593 0.001 3.41e-276 7       SLC45A3  \n17 1.31e-217      12.1  0.556 0.003 3.69e-213 8       PI3      \n18 1.30e-112       8.36 0.578 0.018 3.67e-108 8       C15orf48 \n\n\nWe get a table of marker genes of each cluster.\np_val (P-value before multiple testing): This value represents the statistical significance of differential expression between one cluster and the rest of the clusters combined. A lower p-value indicates stronger evidence for differential expression.\navg_log2FC (Log2 fold change): The average log2 fold change in gene expression between the specified cluster and the rest of the clusters. A positive value indicates upregulation in the specified cluster, while a negative value indicates downregulation.\npct.1 (Percentage of cells expressing the gene in one group): This percentage represents the proportion of cells within the specified cluster that express the gene of interest.\npct.2 (Percentage of cells expressing the gene in another group): Conversely, this percentage represents the proportion of cells in the rest of the clusters combined that express the same gene.\np_val_adj (Adjusted p-value): After correcting for multiple testing, this adjusted p-value accounts for the increased risk of false positives. It helps control the overall false discovery rate.\ngene (Gene name): This column provides the names of the genes being analyzed.\n1.2 FindMarkers\n\nTo identify differentially expressed genes between two clusters, you can utilize the FindMarkers function. This function allows you to compare gene expression levels in one cluster against those in another cluster.\nThe below example finds the differentially expressed genes between cluster 1 and cluster 2.\n\nexample_findmarkers &lt;- FindMarkers(filtered,\n                          assay = \"RNA\",\n                          ident.1 = 1,\n                          ident.2 = 2) %&gt;% \n  rownames_to_column(\"gene\")"
  },
  {
    "objectID": "06_ident_marker.html#automatic-annotation",
    "href": "06_ident_marker.html#automatic-annotation",
    "title": "6. Marker Identification",
    "section": "2. Automatic annotation",
    "text": "2. Automatic annotation\nWhile manual annotation can be time-consuming and iterative, automatic methods offer a more efficient way to assign labels to clusters based on their gene expression profiles. Remember that both manual and automatic annotation have their place in cluster analysis. Combining these approaches can lead to more robust and informative results.\n2.1 Reference-based\nThe reference-based automatic annotation starts with a publicly available dataset that has already been annotated. This dataset serves as your reference. The reference dataset contains clusters of cells, each labeled with specific cell types or conditions.\nBuilding a Reference Set: From the reference dataset, we first create a reference set of marker genes associated with each cluster. These marker genes are crucial for identifying cell types or conditions.\nQuery Dataset: Now, you have a new dataset (the query dataset) that you want to annotate. The query dataset contains similar cell types or conditions but lacks explicit annotations.\nTransferring Annotation: You can transfer the annotation from the reference to the query dataset. This involves comparing gene expression profiles between the query cells and the reference clusters.\nAzimuth is a tool from Seurat that facilitates the transfer of annotations. It provides an interface for connecting the reference information (marker genes) to the query dataset. By analyzing gene expression patterns, it assigns the most likely cell type or condition label to each query cell.\n\n\n\n\n\n\nTip\n\n\n\nBecause the annotation is based on the reference set, ideally the reference dataset is similar to the query. You can check the available reference sets on Azimuth website: https://azimuth.hubmapconsortium.org/\n\n\nWe are working on PBMCs, so we use the reference pbmcref.\n\nfiltered &lt;- Azimuth::RunAzimuth(filtered, reference = \"pbmcref\", verbose = F)\n\nWe can look at the result on a UMAP plot.\n\np1 &lt;- DimPlot(filtered, reduction = \"umap\", \n              group.by = \"predicted.celltype.l1\", \n              label = TRUE, label.size = 3 ,repel = TRUE) + \n  NoLegend()\n\np2 &lt;- DimPlot(filtered, reduction = \"umap\", \n              group.by = \"RNA_snn_res.0.2\", \n              label = TRUE, label.size = 3 ,repel = TRUE) + \n  NoLegend()\n\np1|p2\n\n\n\n\nFor simplicity, we will use the annotation stored in the field predicted.celltype.l1 for the rest of analysis.\n2.1 Marker-based\nThe other type of automatic annotation is to leverage the knowledge of known cell type markers.\nScType is a computational platform designed for this purpose. It operates solely based on given scRNAseq data, combined with a comprehensive cell marker database as background information. It prioritizes highly specific markers for accurate annotation, even for rare cell types with distinct molecular features.\nIt collects the known cell type markers of common tissue types. We already download the known cell type markers from ScType and store it in a file “ScTyepDB_short.xlsx”. You should be able to find this file in the downloaded folder.\n\n# load ScType R functions\nsource(\"https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/R/gene_sets_prepare.R\"); source(\"https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/R/sctype_score_.R\")\n\n# get cell-type-specific gene sets from our in-built database (DB)\n# list downloaded from https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/ScTypeDB_short.xlsx\n# e.g. Immune system, Liver, Pancreas, Kidney, Eye, Brain\ngs_list &lt;-  gene_sets_prepare(\"ScTypeDB_short.xlsx\", \"Immune system\")\n\n# assign cell types\n# NOTE: scRNAseqData parameter should correspond to your input scRNA-seq matrix.\n# In case Seurat is used, it is either GetAssayData(seuratObj[[\"RNA\"]], layer = \"scale.data\"), in case sctransform is used for normalization,\n# or GetAssayData(seuratObj[[\"integrated\"]], layer = \"scale.data\"), in case a joint analysis of multiple single-cell datasets is performed.\nes.max &lt;-  sctype_score(scRNAseqData = GetAssayData(filtered[[\"RNA\"]], layer = \"scale.data\"),\n                        scaled = TRUE,\n                        gs = gs_list$gs_positive,\n                        gs2 = gs_list$gs_negative)\n\n# merge by cluster\ncL_resutls = do.call(\"rbind\", lapply(unique(filtered@meta.data$RNA_snn_res.0.4), function(cl){\n    es.max.cl = sort(rowSums(es.max[ ,rownames(filtered@meta.data[filtered@meta.data$RNA_snn_res.0.4==cl, ])]), decreasing = !0)\n    head(data.frame(cluster = cl, type = names(es.max.cl), scores = es.max.cl, ncells = sum(filtered@meta.data$filtered==cl)), 10)\n}))\n\nsctype_scores = cL_resutls %&gt;% group_by(cluster) %&gt;% top_n(n = 1, wt = scores)\n\n# set low-confident (low ScType score) clusters to \"unknown\"\nsctype_scores$type[as.numeric(as.character(sctype_scores$scores)) &lt; sctype_scores$ncells/4] = \"Unknown\"\n\n\nfiltered@meta.data$customclassif = \"\"\n\nfor(j in unique(sctype_scores$cluster)){\n  cl_type = sctype_scores[sctype_scores$cluster==j,];\n  filtered@meta.data$customclassif[filtered@meta.data$RNA_snn_res.0.4 == j] = as.character(cl_type$type[1])\n}\n\nDimPlot(filtered, reduction = \"umap\", label = TRUE, repel = TRUE, group.by = 'customclassif')"
  },
  {
    "objectID": "08_enrichment_analysis.html",
    "href": "08_enrichment_analysis.html",
    "title": "8. Enrichment Analysis",
    "section": "",
    "text": "# libraries for this chapter\nlibrary(tidyverse)\nlibrary(Seurat)\nlibrary(data.table)\nlibrary(org.Hs.eg.db)\nlibrary(clusterProfiler)\nlibrary(AnnotationDbi)\nlibrary(enrichplot)\nlibrary(biomaRt)\nOftentimes, enrichment analysis takes the DEGs and looks at which gene ontology (GO) terms are enriched.\nGO terms defines concepts/classes used to describe gene function and relationships between these concepts. clusterProfiler is an R package implementing many methods to analyze and visualize functional profiles from a group of features. It classifies functions in three aspects.\nThis chapter uses the differentially expressed genes in CD4+ T cells from last chapter as an example."
  },
  {
    "objectID": "08_enrichment_analysis.html#get-entrez-id",
    "href": "08_enrichment_analysis.html#get-entrez-id",
    "title": "8. Enrichment Analysis",
    "section": "1. Get Entrez ID",
    "text": "1. Get Entrez ID\nclusterProfiler prefers the input of Entrez ID. We use biomaRt package to convert the gene symbol into Entrez ID.\n\n\n\n\n\n\nNote\n\n\n\nbiomaRt is handy to get information about features. You can use it to get gene symbols, genomic coordinates, transcript sequences, etc. You can explore what data is stored in biomaRt with listAttributes.\n\n\nThe differentially expressed genes in CD4+ T cells between naïve and treated PBMCs are stored in the matrix cd4t. The gene symbol in this list can be converted into Entrez ID by biomaRt.\nFirstly, connect to the Ensembl database and specify we want to retrieve information from the dataset of Homo Sapien.\n\nmart &lt;- useMart(biomart = \"ensembl\", dataset = \"hsapiens_gene_ensembl\")\n\n\nbiomart BioMart database connect to. Here, we want to connect to ensembl database.\ndataset Dataset to use. Here specify hsapiens_gene_ensembl.\n\nNext, we can give a list of gene symbols and retrieve the Entrez ID through getBM.\n\nresults &lt;- getBM(attributes = c(\"entrezgene_id\", \"external_gene_name\"),\n                 filters = \"external_gene_name\", \n                 values = rownames(cd4t.deg),\n                 mart = mart)\n\n\nattributes Attributes to retrieve. We want to have the gene symbols and Entrez ID in the results.\nfilters Which filter to use to filter the dataset.\nvalues A list of features as a query.\nmart Object of class Mart, created with the useMart function.\n\nA table of two columns is created and stored in the matrix of results.\n\nresults %&gt;% head\n\n  entrezgene_id external_gene_name\n1          4535             MT-ND1\n2          4536             MT-ND2\n3          4512             MT-CO1\n4          4514             MT-CO3\n5          4537             MT-ND3\n6          4540             MT-ND5\n\n\nNot every gene has the Entrez ID. We keep only genes that have a matched Entrez ID.\n\ncd4t.deg &lt;- cd4t.deg %&gt;% \n  rownames_to_column(\"gene\") %&gt;% \n  left_join(., results, by = c(\"gene\" = \"external_gene_name\")) %&gt;% \n  filter(!is.na(entrezgene_id)) %&gt;% \n  filter(!is.na(p_val_adj))"
  },
  {
    "objectID": "08_enrichment_analysis.html#go-over-representation-analysis",
    "href": "08_enrichment_analysis.html#go-over-representation-analysis",
    "title": "8. Enrichment Analysis",
    "section": "2. GO over-representation analysis",
    "text": "2. GO over-representation analysis\nOver Representation Analysis (ORA) is a widely used approach to determine whether known biological functions or processes are over-represented (= enriched) in an experimentally-derived gene list, e.g. a list of differentially expressed genes (DEGs).\nWe use the enrichGO to get the enriched GO terms in the list of DEGs.\n\ncd4t.deg.sig &lt;- dplyr::filter(cd4t.deg, p_val_adj &lt; 0.05, \n                               abs(avg_log2FC) &gt; 1)\n\n# get the enriched GO terms\nego &lt;- enrichGO(gene = cd4t.deg.sig$entrezgene_id,\n                keyType = \"ENTREZID\",\n                OrgDb = org.Hs.eg.db,\n                ont = \"BP\",\n                pAdjustMethod = \"BH\",\n                pvalueCutoff = 0.01,\n                qvalueCutoff = 0.05,\n                readable = TRUE)\n\n\ngene A list of Entrez gene id.\nkeyType The keytype of input gene.\nOrgDb The database with detailed information about the species.\norg.Hs.eg.db Specify the database of Homo Sapien.\nont One of “BP” (biological process), “MF” (molecular function), and “CC” (cellular component) subontologies, or “ALL” for all three.\npAdjustMethod Multiple testing method for p-value.\npvalueCutoff Adjusted pvalue cutoff on enrichment tests to report.\nqvalueCutoff Tge qvalue cutoff on enrichment tests to report as significant.\nreadable Whether mapping gene ID to gene Name.\n\nLet’s convert the ego object into a data frame and visualize the results in a bar plot.\n\nego.table &lt;- as.data.frame(ego)\n\n\nGeneRatio The gene counts from the input list found in the gene set of a GO term / gene counts of input list.\nBgRatio The gene counts of a geneset / size of all of the unique genes in the collection of genesets.\n\n\nfilter(ego, Description %in% grep(\"T cell\", ego.table$Description, ignore.case = T, value = T)) %&gt;% \nbarplot(showCategory = 18)"
  },
  {
    "objectID": "08_enrichment_analysis.html#gene-set-enrichment-analysis---optional",
    "href": "08_enrichment_analysis.html#gene-set-enrichment-analysis---optional",
    "title": "8. Enrichment Analysis",
    "section": "3. Gene set enrichment analysis - Optional",
    "text": "3. Gene set enrichment analysis - Optional\nAll genes can be used as input of gene set enrichment analysis (GSEA). We first rank the genes based on stat.\n\n# order genes\ncd4t.deg &lt;- cd4t.deg[order(-cd4t.deg$avg_log2FC), ]\n\ngene_list &lt;- cd4t.deg$avg_log2FC\nnames(gene_list) &lt;- cd4t.deg$entrezgene_id\n\nWe use gseGO to perform GSEA and convert the results into a dataframe.\n\n# perform GSEA\ngse &lt;- gseGO(gene_list,\n             keyType = \"ENTREZID\",\n             ont = \"BP\",\n             OrgDb = \"org.Hs.eg.db\")\n\n# convert the results into a dataframe\ngse.table &lt;- as.data.frame(gse) %&gt;% \n  mutate(geneSetID = 1:dim(.)[1])\n\nenrichmentScore The enrichment score (ES) represents the degree to which a set S is over-represented at the top or bottom of the ranked list L.\nWe can look at the enrichment of some GO terms in GSEA plot.\n\ngseaplot2(gse, geneSetID = c(161, 171))\n\n\n\n\nWe have significant enriched term in the unregulated genes. Along the x axis is the ranked genes. Each of the vertical line is one of those genes that are found in this gene set. Along the running line, you can see a lot of genes running together and it falls out when the gene becomes more sparse in the list."
  },
  {
    "objectID": "sessioninfo.html",
    "href": "sessioninfo.html",
    "title": "SessionInfo",
    "section": "",
    "text": "Note\n\n\n\n\nsessionInfo()\n\nR version 4.3.0 (2023-04-21)\nPlatform: x86_64-apple-darwin20 (64-bit)\nRunning under: macOS 14.4.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.3-x86_64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.3-x86_64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Europe/Amsterdam\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nloaded via a namespace (and not attached):\n [1] htmlwidgets_1.6.4 compiler_4.3.0    fastmap_1.1.1     cli_3.6.2        \n [5] tools_4.3.0       htmltools_0.5.8.1 rstudioapi_0.16.0 yaml_2.3.8       \n [9] rmarkdown_2.26    knitr_1.45        jsonlite_1.8.8    xfun_0.42        \n[13] digest_0.6.35     rlang_1.1.3       evaluate_0.23"
  }
]